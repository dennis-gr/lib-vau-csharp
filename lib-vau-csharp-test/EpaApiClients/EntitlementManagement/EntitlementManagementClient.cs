//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 612 // Disable "CS0612 '...' is obsolete"
#pragma warning disable 649 // Disable "CS0649 Field is never assigned to, and will always have its default value null"
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"
#pragma warning disable 8600 // Disable "CS8600 Converting null literal or possible null value to non-nullable type"
#pragma warning disable 8602 // Disable "CS8602 Dereference of a possibly null reference"
#pragma warning disable 8603 // Disable "CS8603 Possible null reference return"
#pragma warning disable 8604 // Disable "CS8604 Possible null reference argument for parameter"
#pragma warning disable 8625 // Disable "CS8625 Cannot convert null literal to non-nullable reference type"
#pragma warning disable 8765 // Disable "CS8765 Nullability of type of parameter doesn't match overridden member (possibly because of nullability attributes)."

namespace lib_vau_csharp_test.EpaApiClients.EntitlementManagement
{
    using System = global::System;

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial interface IEntitlementManagementClient
    {
        /// <summary>
        /// (getEntitlements) Get a list of all granted entitlements, their related user and validity period
        /// </summary>
        /// <remarks>
        /// Get a list of actual granted entitlements of the health record.&lt;/br&gt;
        /// <br/>This operation is limited to entitled users of role oid_versicherter.
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The returned list shall contain only entitlements not expired (_validTo_).&lt;/br&gt;
        /// <br/>
        /// <br/>The operation shall NOT consider the static entitlements for a response (even if stored
        /// <br/>in SecureAdminStorage).
        /// <br/>
        /// <br/> | Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 200 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Requestor has no valid entitlement | 403 | notEntitled ||
        /// <br/>| Requestor role is not _oid_versicherter_ | 403 | invalidOid ||
        /// <br/>| Health record does not exist | 404 | noHealthRecord | _insurantid_ unknown |
        /// <br/>| Health record is not in state ACTIVATED | 409 | statusMismatch ||
        /// <br/>| Any other error | 500 | internalError ||
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| none ||
        /// </remarks>
        /// <param name="x_insurantid">Health Record Identifier.</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK. Returns a list of all entitlements</returns>
        /// <exception cref="EntitlementManagementException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response> GetEntitlementsAsync(string x_insurantid, string x_useragent);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// (getEntitlements) Get a list of all granted entitlements, their related user and validity period
        /// </summary>
        /// <remarks>
        /// Get a list of actual granted entitlements of the health record.&lt;/br&gt;
        /// <br/>This operation is limited to entitled users of role oid_versicherter.
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The returned list shall contain only entitlements not expired (_validTo_).&lt;/br&gt;
        /// <br/>
        /// <br/>The operation shall NOT consider the static entitlements for a response (even if stored
        /// <br/>in SecureAdminStorage).
        /// <br/>
        /// <br/> | Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 200 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Requestor has no valid entitlement | 403 | notEntitled ||
        /// <br/>| Requestor role is not _oid_versicherter_ | 403 | invalidOid ||
        /// <br/>| Health record does not exist | 404 | noHealthRecord | _insurantid_ unknown |
        /// <br/>| Health record is not in state ACTIVATED | 409 | statusMismatch ||
        /// <br/>| Any other error | 500 | internalError ||
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| none ||
        /// </remarks>
        /// <param name="x_insurantid">Health Record Identifier.</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK. Returns a list of all entitlements</returns>
        /// <exception cref="EntitlementManagementException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response> GetEntitlementsAsync(string x_insurantid, string x_useragent, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// (setEntitlement) Set a single entitlement
        /// </summary>
        /// <remarks>
        /// This operation sets a new entitlement for a health record user. Entitlements refer to a specific
        /// <br/>user, identified by its telematik-id or kvnr and grant access to the health record for a specified
        /// <br/>period of time.&lt;/br&gt;
        /// <br/>This operation is limited to entitled users of role oid_versicherter.
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client shall apply a date-time of 9999-12-31T00:00:00.000Z to the _validTo_ claim of a request for unlimited 
        /// <br/>entitlements.&lt;/br&gt;
        /// <br/>A client shall (mandatory) apply a date-time of 9999-12-31T00:00:00Z to the _validTo_ claim of a request if the 
        /// <br/>entitlement addresses a user identified by a kvnr (representative).&lt;/br&gt;
        /// <br/>A client shall (mandatory) apply a date-time of 9999-12-31T00:00:00Z to the _validTo_ claim of a request if the 
        /// <br/>entitlement addresses a DiGA (oid_diga).&lt;/br&gt;
        /// <br/>A client shall (mandatory) apply an email address for notification if a _new_ 
        /// <br/>entitlement addresses a user identified by a kvnr (representative).&lt;/br&gt;
        /// <br/>A client shall delete an assignment of the Blocked User Policy associated to the addressee of this 
        /// <br/>entitlement request first (entitlement is applicable for non-blocked users only).  
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The received JWT shall be passed to the HSM for entitlement verification, using rule _rr1_
        /// <br/>if requestor is the insurant and using rule _rr2_ if requestor is a representative (requestor 
        /// <br/>kvnr != health record identifier).
        /// <br/>
        /// <br/>The HSM rules verify JWT signature, _actorID_, _kvnr_ (associated health record) and claim
        /// <br/>in a CMAC secured result _actorId_, _kvnr_ and _validTo_.
        /// <br/>
        /// <br/>The CMAC secured result shall be completed with the following data:
        /// <br/>- _oid_ of the entitled user (from JWT)
        /// <br/>- _displayName_ of the entitled user (from JWT)
        /// <br/>- _issued-at_ current system time
        /// <br/>- _issued-actorId_ of requestor (from request context)
        /// <br/>- _issued-displayName_ of requestor (from request context)
        /// <br/>
        /// <br/>The completed entitlement shall be stored, encrypted by SecureAdminStorageKey of the health record.&lt;/br&gt;
        /// <br/>Existing entitlements (same _actorId_ and _oid_, _displayName_ ignored) shall automatically be replaced by the completed entitlement.
        /// <br/>
        /// <br/>The completed entitlement shall NOT be stored and cause operation abortion in cases:
        /// <br/>- request claims _actorId_ which is _actorId_ of a static entitlement
        /// <br/>- request claims _actorId_ == kvnr (_oid_ == oid_versicherter) and _validTo_ is not equal 9999-12-31T00:00:00Z
        /// <br/>- request claims _oid_ == oid_diga and _validTo_ is not equal 9999-12-31T00:00:00Z
        /// <br/>- request claims _actorId_ and _actorId_ is referenced by a Blocked User Policy assignment
        /// <br/>- request claims  _actorId_ == kvnr (_oid_ == oid_versicherter) and requestor is not insurant
        /// <br/>- request claims  _actorId_ == kvnr (_oid_ == oid_versicherter), entitlement is new (i.e. does not replace any existing one) and _email_ is not in request 
        /// <br/>- request claims  _validTo_ which is not equal or in the future of current date
        /// <br/>- request claims _actorId_ == kvnr (_oid_ == oid_versicherter) and representative limit already 
        /// <br/>   reached and new request does not replace existing one (i.e. requests entitlement for the 6th representative)
        /// <br/>
        /// <br/>Representative Entitlement:&lt;/br&gt;
        /// <br/>The maximum amount of entitled representatives is five (5). Requests exceeding this limit shall be rejected.
        /// <br/>A request for a new representative entitlement shall provide (mandatory) a notification mail address 
        /// <br/>of the representative. A notification mail shall be sent to the representative using this mail address
        /// <br/>for information about the new established representative role for the insurant's health record, including 
        /// <br/>kvnr and name of the insurant. The mail address provision and the notification is optional in case 
        /// <br/>the new entitlement replaces an existing entitlement of the representative, but if address is available a 
        /// <br/>notification shall be sent.&lt;br&gt;
        /// <br/>The email address shall be discarded after use and shall not be persistet.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 201 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Requestor has no valid entitlement | 403 | notEntitled ||
        /// <br/>| Requestor role is not _oid_versicherter_ | 403 | invalidOid ||
        /// <br/>| HSM verification failed | 403 | invalidToken ||
        /// <br/>| Health record does not exist | 404 | noHealthRecord | _insurantid_ unknown |
        /// <br/>| Health record is not in state ACTIVATED | 409 | statusMismatch | (see 'Retry interval') |
        /// <br/>| request claims _actorId_ which is _actorId_ of a static entitlement | 409 | invalidActorId ||
        /// <br/>| request claims _actorId_ == kvnr (_oid_ == oid_versicherter) and _validTo_ is not equal 9999-12-31T00:00:00Z | 409 | requestMismatch ||
        /// <br/>| request claims _oid_ == oid_diga and _validTo_ is not equal 9999-12-31T00:00:00Z | 409 | requestMismatch ||
        /// <br/>| request claims _actorId_ and _actorId_ is referenced by a Blocked User Policy assignment | 409 | blockedActorId ||
        /// <br/>| request claims  _actorId_ == kvnr (_oid_ == oid_versicherter) and requestor is not insurant | 409 | requestMismatch ||
        /// <br/>| request claims  _actorId_ == kvnr (_oid_ == oid_versicherter) and _email_ is not in request | 409 | noMail ||
        /// <br/>| request claims  _validTo_ which is not equal or in the future of current date | 409 | requestMismatch ||
        /// <br/>| request claims _actorId_ == kvnr (_oid_ == oid_versicherter) and representative limit already reached | 409 | representativeLimit | only if limit is exceeded |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/>&lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| The valid and completed entitlement is stored in SecureDataStorage | a possible existing entitlement is replaced |
        /// <br/>| Entitlement notification is sent | if applicable, for representative entitlement only |
        /// <br/>| A log-entry for the operation exists | successful operation only |
        /// <br/>| The raw-data of the operation is collected and associated to _useragent_ | for any operation result according to gemSpec_Perf UC_A2.2 and UC_A2.5 |
        /// </remarks>
        /// <param name="x_insurantid">Health Record Identifier.</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>Created</returns>
        /// <exception cref="EntitlementManagementException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<EntitlementClaimsResponseType> SetEntitlementAsync(Body body, string x_insurantid, string x_useragent);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// (setEntitlement) Set a single entitlement
        /// </summary>
        /// <remarks>
        /// This operation sets a new entitlement for a health record user. Entitlements refer to a specific
        /// <br/>user, identified by its telematik-id or kvnr and grant access to the health record for a specified
        /// <br/>period of time.&lt;/br&gt;
        /// <br/>This operation is limited to entitled users of role oid_versicherter.
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client shall apply a date-time of 9999-12-31T00:00:00.000Z to the _validTo_ claim of a request for unlimited 
        /// <br/>entitlements.&lt;/br&gt;
        /// <br/>A client shall (mandatory) apply a date-time of 9999-12-31T00:00:00Z to the _validTo_ claim of a request if the 
        /// <br/>entitlement addresses a user identified by a kvnr (representative).&lt;/br&gt;
        /// <br/>A client shall (mandatory) apply a date-time of 9999-12-31T00:00:00Z to the _validTo_ claim of a request if the 
        /// <br/>entitlement addresses a DiGA (oid_diga).&lt;/br&gt;
        /// <br/>A client shall (mandatory) apply an email address for notification if a _new_ 
        /// <br/>entitlement addresses a user identified by a kvnr (representative).&lt;/br&gt;
        /// <br/>A client shall delete an assignment of the Blocked User Policy associated to the addressee of this 
        /// <br/>entitlement request first (entitlement is applicable for non-blocked users only).  
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The received JWT shall be passed to the HSM for entitlement verification, using rule _rr1_
        /// <br/>if requestor is the insurant and using rule _rr2_ if requestor is a representative (requestor 
        /// <br/>kvnr != health record identifier).
        /// <br/>
        /// <br/>The HSM rules verify JWT signature, _actorID_, _kvnr_ (associated health record) and claim
        /// <br/>in a CMAC secured result _actorId_, _kvnr_ and _validTo_.
        /// <br/>
        /// <br/>The CMAC secured result shall be completed with the following data:
        /// <br/>- _oid_ of the entitled user (from JWT)
        /// <br/>- _displayName_ of the entitled user (from JWT)
        /// <br/>- _issued-at_ current system time
        /// <br/>- _issued-actorId_ of requestor (from request context)
        /// <br/>- _issued-displayName_ of requestor (from request context)
        /// <br/>
        /// <br/>The completed entitlement shall be stored, encrypted by SecureAdminStorageKey of the health record.&lt;/br&gt;
        /// <br/>Existing entitlements (same _actorId_ and _oid_, _displayName_ ignored) shall automatically be replaced by the completed entitlement.
        /// <br/>
        /// <br/>The completed entitlement shall NOT be stored and cause operation abortion in cases:
        /// <br/>- request claims _actorId_ which is _actorId_ of a static entitlement
        /// <br/>- request claims _actorId_ == kvnr (_oid_ == oid_versicherter) and _validTo_ is not equal 9999-12-31T00:00:00Z
        /// <br/>- request claims _oid_ == oid_diga and _validTo_ is not equal 9999-12-31T00:00:00Z
        /// <br/>- request claims _actorId_ and _actorId_ is referenced by a Blocked User Policy assignment
        /// <br/>- request claims  _actorId_ == kvnr (_oid_ == oid_versicherter) and requestor is not insurant
        /// <br/>- request claims  _actorId_ == kvnr (_oid_ == oid_versicherter), entitlement is new (i.e. does not replace any existing one) and _email_ is not in request 
        /// <br/>- request claims  _validTo_ which is not equal or in the future of current date
        /// <br/>- request claims _actorId_ == kvnr (_oid_ == oid_versicherter) and representative limit already 
        /// <br/>   reached and new request does not replace existing one (i.e. requests entitlement for the 6th representative)
        /// <br/>
        /// <br/>Representative Entitlement:&lt;/br&gt;
        /// <br/>The maximum amount of entitled representatives is five (5). Requests exceeding this limit shall be rejected.
        /// <br/>A request for a new representative entitlement shall provide (mandatory) a notification mail address 
        /// <br/>of the representative. A notification mail shall be sent to the representative using this mail address
        /// <br/>for information about the new established representative role for the insurant's health record, including 
        /// <br/>kvnr and name of the insurant. The mail address provision and the notification is optional in case 
        /// <br/>the new entitlement replaces an existing entitlement of the representative, but if address is available a 
        /// <br/>notification shall be sent.&lt;br&gt;
        /// <br/>The email address shall be discarded after use and shall not be persistet.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 201 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Requestor has no valid entitlement | 403 | notEntitled ||
        /// <br/>| Requestor role is not _oid_versicherter_ | 403 | invalidOid ||
        /// <br/>| HSM verification failed | 403 | invalidToken ||
        /// <br/>| Health record does not exist | 404 | noHealthRecord | _insurantid_ unknown |
        /// <br/>| Health record is not in state ACTIVATED | 409 | statusMismatch | (see 'Retry interval') |
        /// <br/>| request claims _actorId_ which is _actorId_ of a static entitlement | 409 | invalidActorId ||
        /// <br/>| request claims _actorId_ == kvnr (_oid_ == oid_versicherter) and _validTo_ is not equal 9999-12-31T00:00:00Z | 409 | requestMismatch ||
        /// <br/>| request claims _oid_ == oid_diga and _validTo_ is not equal 9999-12-31T00:00:00Z | 409 | requestMismatch ||
        /// <br/>| request claims _actorId_ and _actorId_ is referenced by a Blocked User Policy assignment | 409 | blockedActorId ||
        /// <br/>| request claims  _actorId_ == kvnr (_oid_ == oid_versicherter) and requestor is not insurant | 409 | requestMismatch ||
        /// <br/>| request claims  _actorId_ == kvnr (_oid_ == oid_versicherter) and _email_ is not in request | 409 | noMail ||
        /// <br/>| request claims  _validTo_ which is not equal or in the future of current date | 409 | requestMismatch ||
        /// <br/>| request claims _actorId_ == kvnr (_oid_ == oid_versicherter) and representative limit already reached | 409 | representativeLimit | only if limit is exceeded |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/>&lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| The valid and completed entitlement is stored in SecureDataStorage | a possible existing entitlement is replaced |
        /// <br/>| Entitlement notification is sent | if applicable, for representative entitlement only |
        /// <br/>| A log-entry for the operation exists | successful operation only |
        /// <br/>| The raw-data of the operation is collected and associated to _useragent_ | for any operation result according to gemSpec_Perf UC_A2.2 and UC_A2.5 |
        /// </remarks>
        /// <param name="x_insurantid">Health Record Identifier.</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>Created</returns>
        /// <exception cref="EntitlementManagementException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<EntitlementClaimsResponseType> SetEntitlementAsync(Body body, string x_insurantid, string x_useragent, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// (getEntitlement) Get a single specific entitlement
        /// </summary>
        /// <remarks>
        /// Get a specific granted and not expired entitlement of the health record.&lt;/br&gt;
        /// <br/>This operation is limited to entitled users of role oid_versicherter. 
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>no recommendations.
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The response shall contain the entitlement related to _actorId_ if available
        /// <br/>
        /// <br/>The operation shall NOT consider the static entitlements for a response (even if stored
        /// <br/>in SecureAdminStorage).
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 200 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Requestor has no valid entitlement | 403 | notEntitled ||
        /// <br/>| Requestor role is not _oid_versicherter_ | 403 | invalidOid ||
        /// <br/>| Health record does not exist | 404 | noHealthRecord | _insurantid_ unknown |
        /// <br/>| Entitlement (_actorId_) does not exist | 404 | noResource | applies also if _actorId_ refers to a static entitlement |
        /// <br/>| Health record is not in state ACTIVATED | 409 | statusMismatch ||
        /// <br/>| Any other error | 500 | internalError ||
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| none ||
        /// </remarks>
        /// <param name="x_insurantid">Health Record Identifier.</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK</returns>
        /// <exception cref="EntitlementManagementException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<EntitlementClaimsResponseType> GetEntitlementAsync(string actorId, string x_insurantid, string x_useragent);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// (getEntitlement) Get a single specific entitlement
        /// </summary>
        /// <remarks>
        /// Get a specific granted and not expired entitlement of the health record.&lt;/br&gt;
        /// <br/>This operation is limited to entitled users of role oid_versicherter. 
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>no recommendations.
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The response shall contain the entitlement related to _actorId_ if available
        /// <br/>
        /// <br/>The operation shall NOT consider the static entitlements for a response (even if stored
        /// <br/>in SecureAdminStorage).
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 200 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Requestor has no valid entitlement | 403 | notEntitled ||
        /// <br/>| Requestor role is not _oid_versicherter_ | 403 | invalidOid ||
        /// <br/>| Health record does not exist | 404 | noHealthRecord | _insurantid_ unknown |
        /// <br/>| Entitlement (_actorId_) does not exist | 404 | noResource | applies also if _actorId_ refers to a static entitlement |
        /// <br/>| Health record is not in state ACTIVATED | 409 | statusMismatch ||
        /// <br/>| Any other error | 500 | internalError ||
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| none ||
        /// </remarks>
        /// <param name="x_insurantid">Health Record Identifier.</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK</returns>
        /// <exception cref="EntitlementManagementException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<EntitlementClaimsResponseType> GetEntitlementAsync(string actorId, string x_insurantid, string x_useragent, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// (deleteEntitlement) Delete a single specific entitlement
        /// </summary>
        /// <remarks>
        /// Delete one existing entitlement.&lt;/br&gt;
        /// <br/>This operation is limited to entitled users of role oid_versicherter.        
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>The client shall not delete static entilements. The client of a representative shall not delete 
        /// <br/>entitlements of other representatives.
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The addressed entitlement shall be finally removed from the SecureAdminStorage.&lt;/br&gt;
        /// <br/>Deletion of entitlements addressing a kvnr (actorId = kvnr, oid = oid_versicherter) shall only be
        /// <br/>successful if requestor is the insurant (kvnr == health record identifier) or the entitled 
        /// <br/>representative (actorId == kvnr of requestor), i.e. a representative shall not delete entitlements 
        /// <br/>of other representatives.&lt;/br&gt;
        /// <br/>Deletion of static entitlements shall not be successful.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 204 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Requestor has no valid entitlement | 403 | notEntitled ||
        /// <br/>| Requestor role is not _oid_versicherter_ | 403 | invalidOid ||
        /// <br/>| Requestor is representative deleting an entitlement of another representative  | 403 | accessDenied ||
        /// <br/>| Health record does not exist | 404 | noHealthRecord | _insurantid_ unknown |
        /// <br/>| Entitlement to delete does not exist | 404 | noResource ||
        /// <br/>| Health record is not in state ACTIVATED | 409 | statusMismatch | (see 'Retry interval') |
        /// <br/>| Parameter _actorId_ refers to a static entitlement| 409 | requestMismatch ||
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| The addressed assignment is removed from the associated policy ||
        /// <br/>| A log-entry for the operation exists | successful operation only |
        /// </remarks>
        /// <param name="x_insurantid">Health Record Identifier.</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK</returns>
        /// <exception cref="EntitlementManagementException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteEntitlementAsync(string actorId, string x_insurantid, string x_useragent);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// (deleteEntitlement) Delete a single specific entitlement
        /// </summary>
        /// <remarks>
        /// Delete one existing entitlement.&lt;/br&gt;
        /// <br/>This operation is limited to entitled users of role oid_versicherter.        
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>The client shall not delete static entilements. The client of a representative shall not delete 
        /// <br/>entitlements of other representatives.
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The addressed entitlement shall be finally removed from the SecureAdminStorage.&lt;/br&gt;
        /// <br/>Deletion of entitlements addressing a kvnr (actorId = kvnr, oid = oid_versicherter) shall only be
        /// <br/>successful if requestor is the insurant (kvnr == health record identifier) or the entitled 
        /// <br/>representative (actorId == kvnr of requestor), i.e. a representative shall not delete entitlements 
        /// <br/>of other representatives.&lt;/br&gt;
        /// <br/>Deletion of static entitlements shall not be successful.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 204 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Requestor has no valid entitlement | 403 | notEntitled ||
        /// <br/>| Requestor role is not _oid_versicherter_ | 403 | invalidOid ||
        /// <br/>| Requestor is representative deleting an entitlement of another representative  | 403 | accessDenied ||
        /// <br/>| Health record does not exist | 404 | noHealthRecord | _insurantid_ unknown |
        /// <br/>| Entitlement to delete does not exist | 404 | noResource ||
        /// <br/>| Health record is not in state ACTIVATED | 409 | statusMismatch | (see 'Retry interval') |
        /// <br/>| Parameter _actorId_ refers to a static entitlement| 409 | requestMismatch ||
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| The addressed assignment is removed from the associated policy ||
        /// <br/>| A log-entry for the operation exists | successful operation only |
        /// </remarks>
        /// <param name="x_insurantid">Health Record Identifier.</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK</returns>
        /// <exception cref="EntitlementManagementException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteEntitlementAsync(string actorId, string x_insurantid, string x_useragent, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// (setEntitlementPs) Set a single entitlement with proof of audit evidence
        /// </summary>
        /// <remarks>
        /// Set an entitlement with predefined validity period for the requesting user in a 
        /// <br/>treatment situation.&lt;/br&gt;
        /// <br/>This operation is limited to users of the "Allowed usergroups for entitlements with proof of audit".
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client shall use this operation in a patient presence situation only, i.e. in case
        /// <br/>the vsdm update service provides a proof of audit as result of a validation procedure
        /// <br/>of a physical health insurance card (eGK) of the health record owner.
        /// <br/>
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>This operation does not require an existing entitlement for the requesting user. Instead,
        /// <br/>an entitlement for this user shall be the result of this operation.
        /// <br/>
        /// <br/>The lack of an existing entitlement for this operation is substituted by verifiable
        /// <br/>evidence (JWT) associated to the health record owner acting as health record owner's explicit
        /// <br/>permission for the requesting user to establish a new entitlement.
        /// <br/>
        /// <br/>The operation shall count the number of failed comparison check of _hcv_ values 
        /// <br/>and also _kvnr_ for each user (telematik-id).
        /// <br/>In case of more than 5 failed comparison checks (5 checks for each counter) within 1 hour
        /// <br/>the operation shall be aborted. 
        /// <br/>
        /// <br/>The received JWT shall be passed to the HSM for entitlement verification, using rule _rr3_.
        /// <br/>
        /// <br/>The HSM rule verifies JWT signature, _actorID_, encryption of _kvnr_ (associated health record) and claims
        /// <br/>in a CMAC secured result _actorId_, _kvnr_ and _validTo_ (_validTo_ is applied by HSM according to 
        /// <br/>user role). HSM verifies also consistence of requestor properties vs claims in JWT signature
        /// <br/>and audit evidence.
        /// <br/>
        /// <br/>The entitlement management enforces the requirements for rate limiting.
        /// <br/>
        /// <br/>The CMAC secured result shall be completed with the following data:
        /// <br/>- _oid_ of the entitled user (from JWT or request context)
        /// <br/>- _displayName_ of the entitled user (from JWT or request context)
        /// <br/>- _issued-at_ current system time
        /// <br/>- _issued-actorId_ of requestor (from request context)
        /// <br/>- _issued-displayName_ of requestor (from request context)
        /// <br/>
        /// <br/>The completed entitlement shall NOT be stored and cause operation abortion in cases:
        /// <br/>- _oid_ is not in the list of allowed usergroups (role)
        /// <br/>- _actorId_ is referenced by a Blocked User Policy assignment
        /// <br/>- _actorId_ is referenced by a Deny List assignment
        /// <br/>
        /// <br/>- if _enforce_hcv_check_ == true or _hcv_ value of JWT and _hcv_ from hsm rule _rr3_ are both available:
        /// <br/>   - _hcv_ value of JWT does not match _hcv_ from hsm rule _rr3_
        /// <br/>- _x-insurantid_ does not match _kvnr_ from hsm rule _rr3_
        /// <br/>
        /// <br/>If an existing and stored entitlement addressing the same user exists and if this stored
        /// <br/>entitlement indicates a _validTo_ which is in the future of the new entitlement's _validTo_, 
        /// <br/>then the existing entitlement shall be kept, else the completed new entitlement shall be stored, 
        /// <br/>encrypted by SecureAdminStorageKey of the health record.&lt;/br&gt;
        /// <br/>If the new entitlement is stored, a possibly existing entitlement is deleted automatically.&lt;/br&gt;
        /// <br/>All above are success cases for this operation.
        /// <br/>The response of the operation shall return the current _validTo_ setting as information.
        /// <br/>
        /// <br/>The addressed user of the request shall be entitled after successful operation.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 201 || even if an existing entitlement is kept due to longer validity |
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Requestor role is not in the list of allowed usergroups | 403 | invalidOid ||
        /// <br/>| Token verification failed | 403 | invalidToken ||
        /// <br/>| Health record does not exist | 404 | noHealthRecord | _insurantid_ unknown |
        /// <br/>| Health record is not in state ACTIVATED | 409 | statusMismatch | (see 'Retry interval') |
        /// <br/>| hcv value of jwt does not exist | 409 | hcvMissing ||
        /// <br/>| request claims _actorId_ and _actorId_ is referenced by a Blocked User Policy assignment | 409 | requestMismatch ||
        /// <br/>| request claims _actorId_ and _actorId_ is referenced by a Deny List assignment | 409 | requestMismatch ||
        /// <br/>| Rate limiting | 423 | locked||
        /// <br/>| to many failed attempts | 423 | locked | _hcv_ check limit |
        /// <br/>| to many failed attempts | 423 | locked | _kvnr_ check limit |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/>&lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| The valid and completed entitlement is stored in SecureDataStorage | a possible existing entitlement with earlier _validTo_ is replaced |
        /// <br/>| The user addressed by the new entitlement is entitled | successful operation only |
        /// <br/>| A log-entry for the operation exists | successful operation only |
        /// <br/>| The raw-data of the operation is collected and associated to _useragent_ | for any operation result according to gemSpec_Perf UC_A2.1 |
        /// </remarks>
        /// <param name="x_insurantid">Health Record Identifier.</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>Created. User is entitled</returns>
        /// <exception cref="EntitlementManagementException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ValidToResponseType> SetEntitlementPsAsync(EntitlementRequestType body, string x_insurantid, string x_useragent);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// (setEntitlementPs) Set a single entitlement with proof of audit evidence
        /// </summary>
        /// <remarks>
        /// Set an entitlement with predefined validity period for the requesting user in a 
        /// <br/>treatment situation.&lt;/br&gt;
        /// <br/>This operation is limited to users of the "Allowed usergroups for entitlements with proof of audit".
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client shall use this operation in a patient presence situation only, i.e. in case
        /// <br/>the vsdm update service provides a proof of audit as result of a validation procedure
        /// <br/>of a physical health insurance card (eGK) of the health record owner.
        /// <br/>
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>This operation does not require an existing entitlement for the requesting user. Instead,
        /// <br/>an entitlement for this user shall be the result of this operation.
        /// <br/>
        /// <br/>The lack of an existing entitlement for this operation is substituted by verifiable
        /// <br/>evidence (JWT) associated to the health record owner acting as health record owner's explicit
        /// <br/>permission for the requesting user to establish a new entitlement.
        /// <br/>
        /// <br/>The operation shall count the number of failed comparison check of _hcv_ values 
        /// <br/>and also _kvnr_ for each user (telematik-id).
        /// <br/>In case of more than 5 failed comparison checks (5 checks for each counter) within 1 hour
        /// <br/>the operation shall be aborted. 
        /// <br/>
        /// <br/>The received JWT shall be passed to the HSM for entitlement verification, using rule _rr3_.
        /// <br/>
        /// <br/>The HSM rule verifies JWT signature, _actorID_, encryption of _kvnr_ (associated health record) and claims
        /// <br/>in a CMAC secured result _actorId_, _kvnr_ and _validTo_ (_validTo_ is applied by HSM according to 
        /// <br/>user role). HSM verifies also consistence of requestor properties vs claims in JWT signature
        /// <br/>and audit evidence.
        /// <br/>
        /// <br/>The entitlement management enforces the requirements for rate limiting.
        /// <br/>
        /// <br/>The CMAC secured result shall be completed with the following data:
        /// <br/>- _oid_ of the entitled user (from JWT or request context)
        /// <br/>- _displayName_ of the entitled user (from JWT or request context)
        /// <br/>- _issued-at_ current system time
        /// <br/>- _issued-actorId_ of requestor (from request context)
        /// <br/>- _issued-displayName_ of requestor (from request context)
        /// <br/>
        /// <br/>The completed entitlement shall NOT be stored and cause operation abortion in cases:
        /// <br/>- _oid_ is not in the list of allowed usergroups (role)
        /// <br/>- _actorId_ is referenced by a Blocked User Policy assignment
        /// <br/>- _actorId_ is referenced by a Deny List assignment
        /// <br/>
        /// <br/>- if _enforce_hcv_check_ == true or _hcv_ value of JWT and _hcv_ from hsm rule _rr3_ are both available:
        /// <br/>   - _hcv_ value of JWT does not match _hcv_ from hsm rule _rr3_
        /// <br/>- _x-insurantid_ does not match _kvnr_ from hsm rule _rr3_
        /// <br/>
        /// <br/>If an existing and stored entitlement addressing the same user exists and if this stored
        /// <br/>entitlement indicates a _validTo_ which is in the future of the new entitlement's _validTo_, 
        /// <br/>then the existing entitlement shall be kept, else the completed new entitlement shall be stored, 
        /// <br/>encrypted by SecureAdminStorageKey of the health record.&lt;/br&gt;
        /// <br/>If the new entitlement is stored, a possibly existing entitlement is deleted automatically.&lt;/br&gt;
        /// <br/>All above are success cases for this operation.
        /// <br/>The response of the operation shall return the current _validTo_ setting as information.
        /// <br/>
        /// <br/>The addressed user of the request shall be entitled after successful operation.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 201 || even if an existing entitlement is kept due to longer validity |
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Requestor role is not in the list of allowed usergroups | 403 | invalidOid ||
        /// <br/>| Token verification failed | 403 | invalidToken ||
        /// <br/>| Health record does not exist | 404 | noHealthRecord | _insurantid_ unknown |
        /// <br/>| Health record is not in state ACTIVATED | 409 | statusMismatch | (see 'Retry interval') |
        /// <br/>| hcv value of jwt does not exist | 409 | hcvMissing ||
        /// <br/>| request claims _actorId_ and _actorId_ is referenced by a Blocked User Policy assignment | 409 | requestMismatch ||
        /// <br/>| request claims _actorId_ and _actorId_ is referenced by a Deny List assignment | 409 | requestMismatch ||
        /// <br/>| Rate limiting | 423 | locked||
        /// <br/>| to many failed attempts | 423 | locked | _hcv_ check limit |
        /// <br/>| to many failed attempts | 423 | locked | _kvnr_ check limit |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/>&lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| The valid and completed entitlement is stored in SecureDataStorage | a possible existing entitlement with earlier _validTo_ is replaced |
        /// <br/>| The user addressed by the new entitlement is entitled | successful operation only |
        /// <br/>| A log-entry for the operation exists | successful operation only |
        /// <br/>| The raw-data of the operation is collected and associated to _useragent_ | for any operation result according to gemSpec_Perf UC_A2.1 |
        /// </remarks>
        /// <param name="x_insurantid">Health Record Identifier.</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>Created. User is entitled</returns>
        /// <exception cref="EntitlementManagementException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<ValidToResponseType> SetEntitlementPsAsync(EntitlementRequestType body, string x_insurantid, string x_useragent, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// (getBlockedUserPolicyAssignments) get a list of blocked users
        /// </summary>
        /// <remarks>
        /// Get a list of actual set assignments of the blocked user policy.&lt;/br&gt;
        /// <br/>This operation is limited to entitled users of role oid_versicherter and oid_ombudsstelle.
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The returned list shall contain only all assignments of the blocked user policy.&lt;/br&gt;
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 200 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Device registration does not exist | 403 | unregisteredDevice | if requestor role is oid_versicherter only |
        /// <br/>| Requestor has no valid entitlement | 403 | notEntitled ||
        /// <br/>| Requestor role is not oid_versicherter_ or _oid_ombudsstelle_| 403 | invalidOid ||
        /// <br/>| Health record does not exist | 404 | noHealthRecord | _insurantid_ unknown |
        /// <br/>| Health record is not in state ACTIVATED | 409 | statusMismatch | (see 'Retry interval') |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| none ||
        /// </remarks>
        /// <param name="x_insurantid">Health Record Identifier.</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>Ok. Returns a list of policy assignments</returns>
        /// <exception cref="EntitlementManagementException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response2> GetBlockedUserPolicyAssignmentsAsync(string x_insurantid, string x_useragent);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// (getBlockedUserPolicyAssignments) get a list of blocked users
        /// </summary>
        /// <remarks>
        /// Get a list of actual set assignments of the blocked user policy.&lt;/br&gt;
        /// <br/>This operation is limited to entitled users of role oid_versicherter and oid_ombudsstelle.
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The returned list shall contain only all assignments of the blocked user policy.&lt;/br&gt;
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 200 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Device registration does not exist | 403 | unregisteredDevice | if requestor role is oid_versicherter only |
        /// <br/>| Requestor has no valid entitlement | 403 | notEntitled ||
        /// <br/>| Requestor role is not oid_versicherter_ or _oid_ombudsstelle_| 403 | invalidOid ||
        /// <br/>| Health record does not exist | 404 | noHealthRecord | _insurantid_ unknown |
        /// <br/>| Health record is not in state ACTIVATED | 409 | statusMismatch | (see 'Retry interval') |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| none ||
        /// </remarks>
        /// <param name="x_insurantid">Health Record Identifier.</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>Ok. Returns a list of policy assignments</returns>
        /// <exception cref="EntitlementManagementException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response2> GetBlockedUserPolicyAssignmentsAsync(string x_insurantid, string x_useragent, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// (setBlockedUserPolicyAssignment) add a user to the blocked user policy
        /// </summary>
        /// <remarks>
        /// Set a new assignment for the blocked user policy.&lt;/br&gt;
        /// <br/>The user addressed by the policy assignment can not be entitled by any means, a possibly existing 
        /// <br/>entitlement is lost.&lt;/br&gt;
        /// <br/>This operation is limited to entitled users of role oid_versicherter and oid_ombudsstelle.
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client shall set assignments for users of the allowed roles for 
        /// <br/>user blocking only.&lt;/br&gt;
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>A valid new assignment shall be added to the blocked user policy.
        /// <br/>
        /// <br/>Each new valid assigment shall be extended by a timestamp (_at_ = current date and time)
        /// <br/>by the server.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 201 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Device registration does not exist | 403 | unregisteredDevice | if requestor role is oid_versicherter only |
        /// <br/>| Requestor has no valid entitlement | 403 | notEntitled ||
        /// <br/>| Requestor role is not _oid_versicherter_ or _oid_ombudsstelle_ | 403 | invalidOid ||
        /// <br/>| Health record does not exist | 404 | noHealthRecord | _insurantid_ unknown |
        /// <br/>| Health record is not in state ACTIVATED | 409 | statusMismatch | (see 'Retry interval') |
        /// <br/>| The assignment parameter _oid_ is not in the list of allowd oids | 409 | requestMismatch ||
        /// <br/>| The assignment does yet exist (same _actorId_) | 409 | requestMismatch | avoid duplicates |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| The policy assignment is extended with the timestamp and stored in SecureDataStorage ||
        /// <br/>| An existing entitlement for the addressed user of the assignment is deleted ||
        /// <br/>| An eMail is sent to the insurant, including information about the blocked user policy change| if eMail address is available |
        /// <br/>| A log-entry for the operation exists | all operation results |
        /// </remarks>
        /// <param name="x_insurantid">Health Record Identifier.</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>Created</returns>
        /// <exception cref="EntitlementManagementException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<BlockedUserPolicyAssignmentResponseType> SetBlockedUserPolicyAssignmentAsync(BlockedUserPolicyAssignmentType body, string x_insurantid, string x_useragent);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// (setBlockedUserPolicyAssignment) add a user to the blocked user policy
        /// </summary>
        /// <remarks>
        /// Set a new assignment for the blocked user policy.&lt;/br&gt;
        /// <br/>The user addressed by the policy assignment can not be entitled by any means, a possibly existing 
        /// <br/>entitlement is lost.&lt;/br&gt;
        /// <br/>This operation is limited to entitled users of role oid_versicherter and oid_ombudsstelle.
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client shall set assignments for users of the allowed roles for 
        /// <br/>user blocking only.&lt;/br&gt;
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>A valid new assignment shall be added to the blocked user policy.
        /// <br/>
        /// <br/>Each new valid assigment shall be extended by a timestamp (_at_ = current date and time)
        /// <br/>by the server.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 201 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Device registration does not exist | 403 | unregisteredDevice | if requestor role is oid_versicherter only |
        /// <br/>| Requestor has no valid entitlement | 403 | notEntitled ||
        /// <br/>| Requestor role is not _oid_versicherter_ or _oid_ombudsstelle_ | 403 | invalidOid ||
        /// <br/>| Health record does not exist | 404 | noHealthRecord | _insurantid_ unknown |
        /// <br/>| Health record is not in state ACTIVATED | 409 | statusMismatch | (see 'Retry interval') |
        /// <br/>| The assignment parameter _oid_ is not in the list of allowd oids | 409 | requestMismatch ||
        /// <br/>| The assignment does yet exist (same _actorId_) | 409 | requestMismatch | avoid duplicates |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| The policy assignment is extended with the timestamp and stored in SecureDataStorage ||
        /// <br/>| An existing entitlement for the addressed user of the assignment is deleted ||
        /// <br/>| An eMail is sent to the insurant, including information about the blocked user policy change| if eMail address is available |
        /// <br/>| A log-entry for the operation exists | all operation results |
        /// </remarks>
        /// <param name="x_insurantid">Health Record Identifier.</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>Created</returns>
        /// <exception cref="EntitlementManagementException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<BlockedUserPolicyAssignmentResponseType> SetBlockedUserPolicyAssignmentAsync(BlockedUserPolicyAssignmentType body, string x_insurantid, string x_useragent, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// (getBlockedUserPolicyAssignment) get a particular blocked user
        /// </summary>
        /// <remarks>
        /// Get one particular assignment of the blocked user policy.&lt;/br&gt;
        /// <br/>This operation is limited to entitled users of role oid_versicherter and oid_ombudsstelle .
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>no recommendations.
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The addressed assigment shall be returned.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 200 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Device registration does not exist | 403 | unregisteredDevice | if requestor role is oid_versicherter only |
        /// <br/>| Requestor has no valid entitlement | 403 | notEntitled ||
        /// <br/>| Requestor role is not oid_versicherter_ or _oid_ombudsstelle_ | 403 | invalidOid ||
        /// <br/>| Health record does not exist | 404 | noHealthRecord | _insurantid_ unknown |
        /// <br/>| Resource for _telematikid_ does not exist | 404 | noResource ||
        /// <br/>| Health record is not in state ACTIVATED | 409 | statusMismatch | (see 'Retry interval') |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| none ||
        /// </remarks>
        /// <param name="x_insurantid">Health Record Identifier.</param>
        /// <param name="telematikid">TelematikID</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>Ok.</returns>
        /// <exception cref="EntitlementManagementException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<BlockedUserPolicyAssignmentResponseType> GetBlockedUserPolicyAssignmentAsync(string x_insurantid, string telematikid, string x_useragent);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// (getBlockedUserPolicyAssignment) get a particular blocked user
        /// </summary>
        /// <remarks>
        /// Get one particular assignment of the blocked user policy.&lt;/br&gt;
        /// <br/>This operation is limited to entitled users of role oid_versicherter and oid_ombudsstelle .
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>no recommendations.
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The addressed assigment shall be returned.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 200 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Device registration does not exist | 403 | unregisteredDevice | if requestor role is oid_versicherter only |
        /// <br/>| Requestor has no valid entitlement | 403 | notEntitled ||
        /// <br/>| Requestor role is not oid_versicherter_ or _oid_ombudsstelle_ | 403 | invalidOid ||
        /// <br/>| Health record does not exist | 404 | noHealthRecord | _insurantid_ unknown |
        /// <br/>| Resource for _telematikid_ does not exist | 404 | noResource ||
        /// <br/>| Health record is not in state ACTIVATED | 409 | statusMismatch | (see 'Retry interval') |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| none ||
        /// </remarks>
        /// <param name="x_insurantid">Health Record Identifier.</param>
        /// <param name="telematikid">TelematikID</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>Ok.</returns>
        /// <exception cref="EntitlementManagementException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<BlockedUserPolicyAssignmentResponseType> GetBlockedUserPolicyAssignmentAsync(string x_insurantid, string telematikid, string x_useragent, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// (deleteBlockedUserPolicyAssignment) remove a user from the blocked user policy
        /// </summary>
        /// <remarks>
        /// Delete one existing assignment of the blocked user policy.&lt;/br&gt;
        /// <br/>This operation is limited to entitled users of role oid_versicherter and oid_ombudsstelle.
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>no recommendations.
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The addressed assigment shall be removed from the policy.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 204 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Device registration does not exist | 403 | unregisteredDevice | if requestor role is oid_versicherter only |
        /// <br/>| Requestor has no valid entitlement | 403 | notEntitled ||
        /// <br/>| Requestor role is not _oid_versicherter_ or _oid_ombudsstelle_| 403 | invalidOid ||
        /// <br/>| Health record does not exist | 404 | noHealthRecord | _insurantid_ unknown |
        /// <br/>| Assignment (_telematikid_) does not exist | 404 | noResource ||
        /// <br/>| Health record is not in state ACTIVATED | 409 | statusMismatch | (see 'Retry interval') |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| The addressed assignment is removed from the associated policy ||
        /// <br/>| An eMail is sent to the insurant, including information about the blocked user policy change| if eMail address is available |
        /// <br/>| A log-entry for the operation exists | all operation results |
        /// </remarks>
        /// <param name="x_insurantid">Health Record Identifier.</param>
        /// <param name="telematikid">TelematikID</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK. Assignment deleted</returns>
        /// <exception cref="EntitlementManagementException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteBlockedUserPolicyAssignmentAsync(string x_insurantid, string telematikid, string x_useragent);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// (deleteBlockedUserPolicyAssignment) remove a user from the blocked user policy
        /// </summary>
        /// <remarks>
        /// Delete one existing assignment of the blocked user policy.&lt;/br&gt;
        /// <br/>This operation is limited to entitled users of role oid_versicherter and oid_ombudsstelle.
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>no recommendations.
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The addressed assigment shall be removed from the policy.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 204 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Device registration does not exist | 403 | unregisteredDevice | if requestor role is oid_versicherter only |
        /// <br/>| Requestor has no valid entitlement | 403 | notEntitled ||
        /// <br/>| Requestor role is not _oid_versicherter_ or _oid_ombudsstelle_| 403 | invalidOid ||
        /// <br/>| Health record does not exist | 404 | noHealthRecord | _insurantid_ unknown |
        /// <br/>| Assignment (_telematikid_) does not exist | 404 | noResource ||
        /// <br/>| Health record is not in state ACTIVATED | 409 | statusMismatch | (see 'Retry interval') |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| The addressed assignment is removed from the associated policy ||
        /// <br/>| An eMail is sent to the insurant, including information about the blocked user policy change| if eMail address is available |
        /// <br/>| A log-entry for the operation exists | all operation results |
        /// </remarks>
        /// <param name="x_insurantid">Health Record Identifier.</param>
        /// <param name="telematikid">TelematikID</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK. Assignment deleted</returns>
        /// <exception cref="EntitlementManagementException">A server side error occurred.</exception>
        System.Threading.Tasks.Task DeleteBlockedUserPolicyAssignmentAsync(string x_insurantid, string telematikid, string x_useragent, System.Threading.CancellationToken cancellationToken);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EntitlementManagementClient : IEntitlementManagementClient
    {
        private System.Net.Http.HttpClient _httpClient;
        private static System.Lazy<System.Text.Json.JsonSerializerOptions> _settings = new System.Lazy<System.Text.Json.JsonSerializerOptions>(CreateSerializerSettings, true);
        private System.Text.Json.JsonSerializerOptions _instanceSettings;

    #pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        public EntitlementManagementClient(System.Net.Http.HttpClient httpClient)
    #pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        {
            _httpClient = httpClient;
            Initialize();
        }

        private static System.Text.Json.JsonSerializerOptions CreateSerializerSettings()
        {
            var settings = new System.Text.Json.JsonSerializerOptions();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        protected System.Text.Json.JsonSerializerOptions JsonSerializerSettings { get { return _instanceSettings ?? _settings.Value; } }

        static partial void UpdateJsonSerializerSettings(System.Text.Json.JsonSerializerOptions settings);

        partial void Initialize();

        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>
        /// (getEntitlements) Get a list of all granted entitlements, their related user and validity period
        /// </summary>
        /// <remarks>
        /// Get a list of actual granted entitlements of the health record.&lt;/br&gt;
        /// <br/>This operation is limited to entitled users of role oid_versicherter.
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The returned list shall contain only entitlements not expired (_validTo_).&lt;/br&gt;
        /// <br/>
        /// <br/>The operation shall NOT consider the static entitlements for a response (even if stored
        /// <br/>in SecureAdminStorage).
        /// <br/>
        /// <br/> | Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 200 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Requestor has no valid entitlement | 403 | notEntitled ||
        /// <br/>| Requestor role is not _oid_versicherter_ | 403 | invalidOid ||
        /// <br/>| Health record does not exist | 404 | noHealthRecord | _insurantid_ unknown |
        /// <br/>| Health record is not in state ACTIVATED | 409 | statusMismatch ||
        /// <br/>| Any other error | 500 | internalError ||
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| none ||
        /// </remarks>
        /// <param name="x_insurantid">Health Record Identifier.</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK. Returns a list of all entitlements</returns>
        /// <exception cref="EntitlementManagementException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response> GetEntitlementsAsync(string x_insurantid, string x_useragent)
        {
            return GetEntitlementsAsync(x_insurantid, x_useragent, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// (getEntitlements) Get a list of all granted entitlements, their related user and validity period
        /// </summary>
        /// <remarks>
        /// Get a list of actual granted entitlements of the health record.&lt;/br&gt;
        /// <br/>This operation is limited to entitled users of role oid_versicherter.
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The returned list shall contain only entitlements not expired (_validTo_).&lt;/br&gt;
        /// <br/>
        /// <br/>The operation shall NOT consider the static entitlements for a response (even if stored
        /// <br/>in SecureAdminStorage).
        /// <br/>
        /// <br/> | Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 200 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Requestor has no valid entitlement | 403 | notEntitled ||
        /// <br/>| Requestor role is not _oid_versicherter_ | 403 | invalidOid ||
        /// <br/>| Health record does not exist | 404 | noHealthRecord | _insurantid_ unknown |
        /// <br/>| Health record is not in state ACTIVATED | 409 | statusMismatch ||
        /// <br/>| Any other error | 500 | internalError ||
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| none ||
        /// </remarks>
        /// <param name="x_insurantid">Health Record Identifier.</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK. Returns a list of all entitlements</returns>
        /// <exception cref="EntitlementManagementException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response> GetEntitlementsAsync(string x_insurantid, string x_useragent, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (x_insurantid == null)
                        throw new System.ArgumentNullException("x_insurantid");
                    request_.Headers.TryAddWithoutValidation("x-insurantid", ConvertToString(x_insurantid, System.Globalization.CultureInfo.InvariantCulture));

                    if (x_useragent == null)
                        throw new System.ArgumentNullException("x_useragent");
                    request_.Headers.TryAddWithoutValidation("x-useragent", ConvertToString(x_useragent, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "epa/basic/api/v1/entitlements"
                    urlBuilder_.Append("epa/basic/api/v1/entitlements");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Bad Request.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Forbidden.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Not found.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Conflict.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new EntitlementManagementException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// (setEntitlement) Set a single entitlement
        /// </summary>
        /// <remarks>
        /// This operation sets a new entitlement for a health record user. Entitlements refer to a specific
        /// <br/>user, identified by its telematik-id or kvnr and grant access to the health record for a specified
        /// <br/>period of time.&lt;/br&gt;
        /// <br/>This operation is limited to entitled users of role oid_versicherter.
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client shall apply a date-time of 9999-12-31T00:00:00.000Z to the _validTo_ claim of a request for unlimited 
        /// <br/>entitlements.&lt;/br&gt;
        /// <br/>A client shall (mandatory) apply a date-time of 9999-12-31T00:00:00Z to the _validTo_ claim of a request if the 
        /// <br/>entitlement addresses a user identified by a kvnr (representative).&lt;/br&gt;
        /// <br/>A client shall (mandatory) apply a date-time of 9999-12-31T00:00:00Z to the _validTo_ claim of a request if the 
        /// <br/>entitlement addresses a DiGA (oid_diga).&lt;/br&gt;
        /// <br/>A client shall (mandatory) apply an email address for notification if a _new_ 
        /// <br/>entitlement addresses a user identified by a kvnr (representative).&lt;/br&gt;
        /// <br/>A client shall delete an assignment of the Blocked User Policy associated to the addressee of this 
        /// <br/>entitlement request first (entitlement is applicable for non-blocked users only).  
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The received JWT shall be passed to the HSM for entitlement verification, using rule _rr1_
        /// <br/>if requestor is the insurant and using rule _rr2_ if requestor is a representative (requestor 
        /// <br/>kvnr != health record identifier).
        /// <br/>
        /// <br/>The HSM rules verify JWT signature, _actorID_, _kvnr_ (associated health record) and claim
        /// <br/>in a CMAC secured result _actorId_, _kvnr_ and _validTo_.
        /// <br/>
        /// <br/>The CMAC secured result shall be completed with the following data:
        /// <br/>- _oid_ of the entitled user (from JWT)
        /// <br/>- _displayName_ of the entitled user (from JWT)
        /// <br/>- _issued-at_ current system time
        /// <br/>- _issued-actorId_ of requestor (from request context)
        /// <br/>- _issued-displayName_ of requestor (from request context)
        /// <br/>
        /// <br/>The completed entitlement shall be stored, encrypted by SecureAdminStorageKey of the health record.&lt;/br&gt;
        /// <br/>Existing entitlements (same _actorId_ and _oid_, _displayName_ ignored) shall automatically be replaced by the completed entitlement.
        /// <br/>
        /// <br/>The completed entitlement shall NOT be stored and cause operation abortion in cases:
        /// <br/>- request claims _actorId_ which is _actorId_ of a static entitlement
        /// <br/>- request claims _actorId_ == kvnr (_oid_ == oid_versicherter) and _validTo_ is not equal 9999-12-31T00:00:00Z
        /// <br/>- request claims _oid_ == oid_diga and _validTo_ is not equal 9999-12-31T00:00:00Z
        /// <br/>- request claims _actorId_ and _actorId_ is referenced by a Blocked User Policy assignment
        /// <br/>- request claims  _actorId_ == kvnr (_oid_ == oid_versicherter) and requestor is not insurant
        /// <br/>- request claims  _actorId_ == kvnr (_oid_ == oid_versicherter), entitlement is new (i.e. does not replace any existing one) and _email_ is not in request 
        /// <br/>- request claims  _validTo_ which is not equal or in the future of current date
        /// <br/>- request claims _actorId_ == kvnr (_oid_ == oid_versicherter) and representative limit already 
        /// <br/>   reached and new request does not replace existing one (i.e. requests entitlement for the 6th representative)
        /// <br/>
        /// <br/>Representative Entitlement:&lt;/br&gt;
        /// <br/>The maximum amount of entitled representatives is five (5). Requests exceeding this limit shall be rejected.
        /// <br/>A request for a new representative entitlement shall provide (mandatory) a notification mail address 
        /// <br/>of the representative. A notification mail shall be sent to the representative using this mail address
        /// <br/>for information about the new established representative role for the insurant's health record, including 
        /// <br/>kvnr and name of the insurant. The mail address provision and the notification is optional in case 
        /// <br/>the new entitlement replaces an existing entitlement of the representative, but if address is available a 
        /// <br/>notification shall be sent.&lt;br&gt;
        /// <br/>The email address shall be discarded after use and shall not be persistet.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 201 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Requestor has no valid entitlement | 403 | notEntitled ||
        /// <br/>| Requestor role is not _oid_versicherter_ | 403 | invalidOid ||
        /// <br/>| HSM verification failed | 403 | invalidToken ||
        /// <br/>| Health record does not exist | 404 | noHealthRecord | _insurantid_ unknown |
        /// <br/>| Health record is not in state ACTIVATED | 409 | statusMismatch | (see 'Retry interval') |
        /// <br/>| request claims _actorId_ which is _actorId_ of a static entitlement | 409 | invalidActorId ||
        /// <br/>| request claims _actorId_ == kvnr (_oid_ == oid_versicherter) and _validTo_ is not equal 9999-12-31T00:00:00Z | 409 | requestMismatch ||
        /// <br/>| request claims _oid_ == oid_diga and _validTo_ is not equal 9999-12-31T00:00:00Z | 409 | requestMismatch ||
        /// <br/>| request claims _actorId_ and _actorId_ is referenced by a Blocked User Policy assignment | 409 | blockedActorId ||
        /// <br/>| request claims  _actorId_ == kvnr (_oid_ == oid_versicherter) and requestor is not insurant | 409 | requestMismatch ||
        /// <br/>| request claims  _actorId_ == kvnr (_oid_ == oid_versicherter) and _email_ is not in request | 409 | noMail ||
        /// <br/>| request claims  _validTo_ which is not equal or in the future of current date | 409 | requestMismatch ||
        /// <br/>| request claims _actorId_ == kvnr (_oid_ == oid_versicherter) and representative limit already reached | 409 | representativeLimit | only if limit is exceeded |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/>&lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| The valid and completed entitlement is stored in SecureDataStorage | a possible existing entitlement is replaced |
        /// <br/>| Entitlement notification is sent | if applicable, for representative entitlement only |
        /// <br/>| A log-entry for the operation exists | successful operation only |
        /// <br/>| The raw-data of the operation is collected and associated to _useragent_ | for any operation result according to gemSpec_Perf UC_A2.2 and UC_A2.5 |
        /// </remarks>
        /// <param name="x_insurantid">Health Record Identifier.</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>Created</returns>
        /// <exception cref="EntitlementManagementException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<EntitlementClaimsResponseType> SetEntitlementAsync(Body body, string x_insurantid, string x_useragent)
        {
            return SetEntitlementAsync(body, x_insurantid, x_useragent, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// (setEntitlement) Set a single entitlement
        /// </summary>
        /// <remarks>
        /// This operation sets a new entitlement for a health record user. Entitlements refer to a specific
        /// <br/>user, identified by its telematik-id or kvnr and grant access to the health record for a specified
        /// <br/>period of time.&lt;/br&gt;
        /// <br/>This operation is limited to entitled users of role oid_versicherter.
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client shall apply a date-time of 9999-12-31T00:00:00.000Z to the _validTo_ claim of a request for unlimited 
        /// <br/>entitlements.&lt;/br&gt;
        /// <br/>A client shall (mandatory) apply a date-time of 9999-12-31T00:00:00Z to the _validTo_ claim of a request if the 
        /// <br/>entitlement addresses a user identified by a kvnr (representative).&lt;/br&gt;
        /// <br/>A client shall (mandatory) apply a date-time of 9999-12-31T00:00:00Z to the _validTo_ claim of a request if the 
        /// <br/>entitlement addresses a DiGA (oid_diga).&lt;/br&gt;
        /// <br/>A client shall (mandatory) apply an email address for notification if a _new_ 
        /// <br/>entitlement addresses a user identified by a kvnr (representative).&lt;/br&gt;
        /// <br/>A client shall delete an assignment of the Blocked User Policy associated to the addressee of this 
        /// <br/>entitlement request first (entitlement is applicable for non-blocked users only).  
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The received JWT shall be passed to the HSM for entitlement verification, using rule _rr1_
        /// <br/>if requestor is the insurant and using rule _rr2_ if requestor is a representative (requestor 
        /// <br/>kvnr != health record identifier).
        /// <br/>
        /// <br/>The HSM rules verify JWT signature, _actorID_, _kvnr_ (associated health record) and claim
        /// <br/>in a CMAC secured result _actorId_, _kvnr_ and _validTo_.
        /// <br/>
        /// <br/>The CMAC secured result shall be completed with the following data:
        /// <br/>- _oid_ of the entitled user (from JWT)
        /// <br/>- _displayName_ of the entitled user (from JWT)
        /// <br/>- _issued-at_ current system time
        /// <br/>- _issued-actorId_ of requestor (from request context)
        /// <br/>- _issued-displayName_ of requestor (from request context)
        /// <br/>
        /// <br/>The completed entitlement shall be stored, encrypted by SecureAdminStorageKey of the health record.&lt;/br&gt;
        /// <br/>Existing entitlements (same _actorId_ and _oid_, _displayName_ ignored) shall automatically be replaced by the completed entitlement.
        /// <br/>
        /// <br/>The completed entitlement shall NOT be stored and cause operation abortion in cases:
        /// <br/>- request claims _actorId_ which is _actorId_ of a static entitlement
        /// <br/>- request claims _actorId_ == kvnr (_oid_ == oid_versicherter) and _validTo_ is not equal 9999-12-31T00:00:00Z
        /// <br/>- request claims _oid_ == oid_diga and _validTo_ is not equal 9999-12-31T00:00:00Z
        /// <br/>- request claims _actorId_ and _actorId_ is referenced by a Blocked User Policy assignment
        /// <br/>- request claims  _actorId_ == kvnr (_oid_ == oid_versicherter) and requestor is not insurant
        /// <br/>- request claims  _actorId_ == kvnr (_oid_ == oid_versicherter), entitlement is new (i.e. does not replace any existing one) and _email_ is not in request 
        /// <br/>- request claims  _validTo_ which is not equal or in the future of current date
        /// <br/>- request claims _actorId_ == kvnr (_oid_ == oid_versicherter) and representative limit already 
        /// <br/>   reached and new request does not replace existing one (i.e. requests entitlement for the 6th representative)
        /// <br/>
        /// <br/>Representative Entitlement:&lt;/br&gt;
        /// <br/>The maximum amount of entitled representatives is five (5). Requests exceeding this limit shall be rejected.
        /// <br/>A request for a new representative entitlement shall provide (mandatory) a notification mail address 
        /// <br/>of the representative. A notification mail shall be sent to the representative using this mail address
        /// <br/>for information about the new established representative role for the insurant's health record, including 
        /// <br/>kvnr and name of the insurant. The mail address provision and the notification is optional in case 
        /// <br/>the new entitlement replaces an existing entitlement of the representative, but if address is available a 
        /// <br/>notification shall be sent.&lt;br&gt;
        /// <br/>The email address shall be discarded after use and shall not be persistet.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 201 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Requestor has no valid entitlement | 403 | notEntitled ||
        /// <br/>| Requestor role is not _oid_versicherter_ | 403 | invalidOid ||
        /// <br/>| HSM verification failed | 403 | invalidToken ||
        /// <br/>| Health record does not exist | 404 | noHealthRecord | _insurantid_ unknown |
        /// <br/>| Health record is not in state ACTIVATED | 409 | statusMismatch | (see 'Retry interval') |
        /// <br/>| request claims _actorId_ which is _actorId_ of a static entitlement | 409 | invalidActorId ||
        /// <br/>| request claims _actorId_ == kvnr (_oid_ == oid_versicherter) and _validTo_ is not equal 9999-12-31T00:00:00Z | 409 | requestMismatch ||
        /// <br/>| request claims _oid_ == oid_diga and _validTo_ is not equal 9999-12-31T00:00:00Z | 409 | requestMismatch ||
        /// <br/>| request claims _actorId_ and _actorId_ is referenced by a Blocked User Policy assignment | 409 | blockedActorId ||
        /// <br/>| request claims  _actorId_ == kvnr (_oid_ == oid_versicherter) and requestor is not insurant | 409 | requestMismatch ||
        /// <br/>| request claims  _actorId_ == kvnr (_oid_ == oid_versicherter) and _email_ is not in request | 409 | noMail ||
        /// <br/>| request claims  _validTo_ which is not equal or in the future of current date | 409 | requestMismatch ||
        /// <br/>| request claims _actorId_ == kvnr (_oid_ == oid_versicherter) and representative limit already reached | 409 | representativeLimit | only if limit is exceeded |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/>&lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| The valid and completed entitlement is stored in SecureDataStorage | a possible existing entitlement is replaced |
        /// <br/>| Entitlement notification is sent | if applicable, for representative entitlement only |
        /// <br/>| A log-entry for the operation exists | successful operation only |
        /// <br/>| The raw-data of the operation is collected and associated to _useragent_ | for any operation result according to gemSpec_Perf UC_A2.2 and UC_A2.5 |
        /// </remarks>
        /// <param name="x_insurantid">Health Record Identifier.</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>Created</returns>
        /// <exception cref="EntitlementManagementException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<EntitlementClaimsResponseType> SetEntitlementAsync(Body body, string x_insurantid, string x_useragent, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (x_insurantid == null)
                        throw new System.ArgumentNullException("x_insurantid");
                    request_.Headers.TryAddWithoutValidation("x-insurantid", ConvertToString(x_insurantid, System.Globalization.CultureInfo.InvariantCulture));

                    if (x_useragent == null)
                        throw new System.ArgumentNullException("x_useragent");
                    request_.Headers.TryAddWithoutValidation("x-useragent", ConvertToString(x_useragent, System.Globalization.CultureInfo.InvariantCulture));
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "epa/basic/api/v1/entitlements"
                    urlBuilder_.Append("epa/basic/api/v1/entitlements");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 201)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<EntitlementClaimsResponseType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Bad Request.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Forbidden.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Not found.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Conflict.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new EntitlementManagementException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// (getEntitlement) Get a single specific entitlement
        /// </summary>
        /// <remarks>
        /// Get a specific granted and not expired entitlement of the health record.&lt;/br&gt;
        /// <br/>This operation is limited to entitled users of role oid_versicherter. 
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>no recommendations.
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The response shall contain the entitlement related to _actorId_ if available
        /// <br/>
        /// <br/>The operation shall NOT consider the static entitlements for a response (even if stored
        /// <br/>in SecureAdminStorage).
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 200 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Requestor has no valid entitlement | 403 | notEntitled ||
        /// <br/>| Requestor role is not _oid_versicherter_ | 403 | invalidOid ||
        /// <br/>| Health record does not exist | 404 | noHealthRecord | _insurantid_ unknown |
        /// <br/>| Entitlement (_actorId_) does not exist | 404 | noResource | applies also if _actorId_ refers to a static entitlement |
        /// <br/>| Health record is not in state ACTIVATED | 409 | statusMismatch ||
        /// <br/>| Any other error | 500 | internalError ||
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| none ||
        /// </remarks>
        /// <param name="x_insurantid">Health Record Identifier.</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK</returns>
        /// <exception cref="EntitlementManagementException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<EntitlementClaimsResponseType> GetEntitlementAsync(string actorId, string x_insurantid, string x_useragent)
        {
            return GetEntitlementAsync(actorId, x_insurantid, x_useragent, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// (getEntitlement) Get a single specific entitlement
        /// </summary>
        /// <remarks>
        /// Get a specific granted and not expired entitlement of the health record.&lt;/br&gt;
        /// <br/>This operation is limited to entitled users of role oid_versicherter. 
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>no recommendations.
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The response shall contain the entitlement related to _actorId_ if available
        /// <br/>
        /// <br/>The operation shall NOT consider the static entitlements for a response (even if stored
        /// <br/>in SecureAdminStorage).
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 200 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Requestor has no valid entitlement | 403 | notEntitled ||
        /// <br/>| Requestor role is not _oid_versicherter_ | 403 | invalidOid ||
        /// <br/>| Health record does not exist | 404 | noHealthRecord | _insurantid_ unknown |
        /// <br/>| Entitlement (_actorId_) does not exist | 404 | noResource | applies also if _actorId_ refers to a static entitlement |
        /// <br/>| Health record is not in state ACTIVATED | 409 | statusMismatch ||
        /// <br/>| Any other error | 500 | internalError ||
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| none ||
        /// </remarks>
        /// <param name="x_insurantid">Health Record Identifier.</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK</returns>
        /// <exception cref="EntitlementManagementException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<EntitlementClaimsResponseType> GetEntitlementAsync(string actorId, string x_insurantid, string x_useragent, System.Threading.CancellationToken cancellationToken)
        {
            if (actorId == null)
                throw new System.ArgumentNullException("actorId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (x_insurantid == null)
                        throw new System.ArgumentNullException("x_insurantid");
                    request_.Headers.TryAddWithoutValidation("x-insurantid", ConvertToString(x_insurantid, System.Globalization.CultureInfo.InvariantCulture));

                    if (x_useragent == null)
                        throw new System.ArgumentNullException("x_useragent");
                    request_.Headers.TryAddWithoutValidation("x-useragent", ConvertToString(x_useragent, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "epa/basic/api/v1/entitlements/{actorId}"
                    urlBuilder_.Append("epa/basic/api/v1/entitlements/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(actorId, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<EntitlementClaimsResponseType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Bad Request.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Forbidden.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Not found.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Conflict.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new EntitlementManagementException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// (deleteEntitlement) Delete a single specific entitlement
        /// </summary>
        /// <remarks>
        /// Delete one existing entitlement.&lt;/br&gt;
        /// <br/>This operation is limited to entitled users of role oid_versicherter.        
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>The client shall not delete static entilements. The client of a representative shall not delete 
        /// <br/>entitlements of other representatives.
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The addressed entitlement shall be finally removed from the SecureAdminStorage.&lt;/br&gt;
        /// <br/>Deletion of entitlements addressing a kvnr (actorId = kvnr, oid = oid_versicherter) shall only be
        /// <br/>successful if requestor is the insurant (kvnr == health record identifier) or the entitled 
        /// <br/>representative (actorId == kvnr of requestor), i.e. a representative shall not delete entitlements 
        /// <br/>of other representatives.&lt;/br&gt;
        /// <br/>Deletion of static entitlements shall not be successful.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 204 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Requestor has no valid entitlement | 403 | notEntitled ||
        /// <br/>| Requestor role is not _oid_versicherter_ | 403 | invalidOid ||
        /// <br/>| Requestor is representative deleting an entitlement of another representative  | 403 | accessDenied ||
        /// <br/>| Health record does not exist | 404 | noHealthRecord | _insurantid_ unknown |
        /// <br/>| Entitlement to delete does not exist | 404 | noResource ||
        /// <br/>| Health record is not in state ACTIVATED | 409 | statusMismatch | (see 'Retry interval') |
        /// <br/>| Parameter _actorId_ refers to a static entitlement| 409 | requestMismatch ||
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| The addressed assignment is removed from the associated policy ||
        /// <br/>| A log-entry for the operation exists | successful operation only |
        /// </remarks>
        /// <param name="x_insurantid">Health Record Identifier.</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK</returns>
        /// <exception cref="EntitlementManagementException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteEntitlementAsync(string actorId, string x_insurantid, string x_useragent)
        {
            return DeleteEntitlementAsync(actorId, x_insurantid, x_useragent, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// (deleteEntitlement) Delete a single specific entitlement
        /// </summary>
        /// <remarks>
        /// Delete one existing entitlement.&lt;/br&gt;
        /// <br/>This operation is limited to entitled users of role oid_versicherter.        
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>The client shall not delete static entilements. The client of a representative shall not delete 
        /// <br/>entitlements of other representatives.
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The addressed entitlement shall be finally removed from the SecureAdminStorage.&lt;/br&gt;
        /// <br/>Deletion of entitlements addressing a kvnr (actorId = kvnr, oid = oid_versicherter) shall only be
        /// <br/>successful if requestor is the insurant (kvnr == health record identifier) or the entitled 
        /// <br/>representative (actorId == kvnr of requestor), i.e. a representative shall not delete entitlements 
        /// <br/>of other representatives.&lt;/br&gt;
        /// <br/>Deletion of static entitlements shall not be successful.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 204 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Requestor has no valid entitlement | 403 | notEntitled ||
        /// <br/>| Requestor role is not _oid_versicherter_ | 403 | invalidOid ||
        /// <br/>| Requestor is representative deleting an entitlement of another representative  | 403 | accessDenied ||
        /// <br/>| Health record does not exist | 404 | noHealthRecord | _insurantid_ unknown |
        /// <br/>| Entitlement to delete does not exist | 404 | noResource ||
        /// <br/>| Health record is not in state ACTIVATED | 409 | statusMismatch | (see 'Retry interval') |
        /// <br/>| Parameter _actorId_ refers to a static entitlement| 409 | requestMismatch ||
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| The addressed assignment is removed from the associated policy ||
        /// <br/>| A log-entry for the operation exists | successful operation only |
        /// </remarks>
        /// <param name="x_insurantid">Health Record Identifier.</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK</returns>
        /// <exception cref="EntitlementManagementException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteEntitlementAsync(string actorId, string x_insurantid, string x_useragent, System.Threading.CancellationToken cancellationToken)
        {
            if (actorId == null)
                throw new System.ArgumentNullException("actorId");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (x_insurantid == null)
                        throw new System.ArgumentNullException("x_insurantid");
                    request_.Headers.TryAddWithoutValidation("x-insurantid", ConvertToString(x_insurantid, System.Globalization.CultureInfo.InvariantCulture));

                    if (x_useragent == null)
                        throw new System.ArgumentNullException("x_useragent");
                    request_.Headers.TryAddWithoutValidation("x-useragent", ConvertToString(x_useragent, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "epa/basic/api/v1/entitlements/{actorId}"
                    urlBuilder_.Append("epa/basic/api/v1/entitlements/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(actorId, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Bad Request.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Forbidden.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Not found.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Conflict.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new EntitlementManagementException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// (setEntitlementPs) Set a single entitlement with proof of audit evidence
        /// </summary>
        /// <remarks>
        /// Set an entitlement with predefined validity period for the requesting user in a 
        /// <br/>treatment situation.&lt;/br&gt;
        /// <br/>This operation is limited to users of the "Allowed usergroups for entitlements with proof of audit".
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client shall use this operation in a patient presence situation only, i.e. in case
        /// <br/>the vsdm update service provides a proof of audit as result of a validation procedure
        /// <br/>of a physical health insurance card (eGK) of the health record owner.
        /// <br/>
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>This operation does not require an existing entitlement for the requesting user. Instead,
        /// <br/>an entitlement for this user shall be the result of this operation.
        /// <br/>
        /// <br/>The lack of an existing entitlement for this operation is substituted by verifiable
        /// <br/>evidence (JWT) associated to the health record owner acting as health record owner's explicit
        /// <br/>permission for the requesting user to establish a new entitlement.
        /// <br/>
        /// <br/>The operation shall count the number of failed comparison check of _hcv_ values 
        /// <br/>and also _kvnr_ for each user (telematik-id).
        /// <br/>In case of more than 5 failed comparison checks (5 checks for each counter) within 1 hour
        /// <br/>the operation shall be aborted. 
        /// <br/>
        /// <br/>The received JWT shall be passed to the HSM for entitlement verification, using rule _rr3_.
        /// <br/>
        /// <br/>The HSM rule verifies JWT signature, _actorID_, encryption of _kvnr_ (associated health record) and claims
        /// <br/>in a CMAC secured result _actorId_, _kvnr_ and _validTo_ (_validTo_ is applied by HSM according to 
        /// <br/>user role). HSM verifies also consistence of requestor properties vs claims in JWT signature
        /// <br/>and audit evidence.
        /// <br/>
        /// <br/>The entitlement management enforces the requirements for rate limiting.
        /// <br/>
        /// <br/>The CMAC secured result shall be completed with the following data:
        /// <br/>- _oid_ of the entitled user (from JWT or request context)
        /// <br/>- _displayName_ of the entitled user (from JWT or request context)
        /// <br/>- _issued-at_ current system time
        /// <br/>- _issued-actorId_ of requestor (from request context)
        /// <br/>- _issued-displayName_ of requestor (from request context)
        /// <br/>
        /// <br/>The completed entitlement shall NOT be stored and cause operation abortion in cases:
        /// <br/>- _oid_ is not in the list of allowed usergroups (role)
        /// <br/>- _actorId_ is referenced by a Blocked User Policy assignment
        /// <br/>- _actorId_ is referenced by a Deny List assignment
        /// <br/>
        /// <br/>- if _enforce_hcv_check_ == true or _hcv_ value of JWT and _hcv_ from hsm rule _rr3_ are both available:
        /// <br/>   - _hcv_ value of JWT does not match _hcv_ from hsm rule _rr3_
        /// <br/>- _x-insurantid_ does not match _kvnr_ from hsm rule _rr3_
        /// <br/>
        /// <br/>If an existing and stored entitlement addressing the same user exists and if this stored
        /// <br/>entitlement indicates a _validTo_ which is in the future of the new entitlement's _validTo_, 
        /// <br/>then the existing entitlement shall be kept, else the completed new entitlement shall be stored, 
        /// <br/>encrypted by SecureAdminStorageKey of the health record.&lt;/br&gt;
        /// <br/>If the new entitlement is stored, a possibly existing entitlement is deleted automatically.&lt;/br&gt;
        /// <br/>All above are success cases for this operation.
        /// <br/>The response of the operation shall return the current _validTo_ setting as information.
        /// <br/>
        /// <br/>The addressed user of the request shall be entitled after successful operation.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 201 || even if an existing entitlement is kept due to longer validity |
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Requestor role is not in the list of allowed usergroups | 403 | invalidOid ||
        /// <br/>| Token verification failed | 403 | invalidToken ||
        /// <br/>| Health record does not exist | 404 | noHealthRecord | _insurantid_ unknown |
        /// <br/>| Health record is not in state ACTIVATED | 409 | statusMismatch | (see 'Retry interval') |
        /// <br/>| hcv value of jwt does not exist | 409 | hcvMissing ||
        /// <br/>| request claims _actorId_ and _actorId_ is referenced by a Blocked User Policy assignment | 409 | requestMismatch ||
        /// <br/>| request claims _actorId_ and _actorId_ is referenced by a Deny List assignment | 409 | requestMismatch ||
        /// <br/>| Rate limiting | 423 | locked||
        /// <br/>| to many failed attempts | 423 | locked | _hcv_ check limit |
        /// <br/>| to many failed attempts | 423 | locked | _kvnr_ check limit |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/>&lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| The valid and completed entitlement is stored in SecureDataStorage | a possible existing entitlement with earlier _validTo_ is replaced |
        /// <br/>| The user addressed by the new entitlement is entitled | successful operation only |
        /// <br/>| A log-entry for the operation exists | successful operation only |
        /// <br/>| The raw-data of the operation is collected and associated to _useragent_ | for any operation result according to gemSpec_Perf UC_A2.1 |
        /// </remarks>
        /// <param name="x_insurantid">Health Record Identifier.</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>Created. User is entitled</returns>
        /// <exception cref="EntitlementManagementException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<ValidToResponseType> SetEntitlementPsAsync(EntitlementRequestType body, string x_insurantid, string x_useragent)
        {
            return SetEntitlementPsAsync(body, x_insurantid, x_useragent, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// (setEntitlementPs) Set a single entitlement with proof of audit evidence
        /// </summary>
        /// <remarks>
        /// Set an entitlement with predefined validity period for the requesting user in a 
        /// <br/>treatment situation.&lt;/br&gt;
        /// <br/>This operation is limited to users of the "Allowed usergroups for entitlements with proof of audit".
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client shall use this operation in a patient presence situation only, i.e. in case
        /// <br/>the vsdm update service provides a proof of audit as result of a validation procedure
        /// <br/>of a physical health insurance card (eGK) of the health record owner.
        /// <br/>
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>This operation does not require an existing entitlement for the requesting user. Instead,
        /// <br/>an entitlement for this user shall be the result of this operation.
        /// <br/>
        /// <br/>The lack of an existing entitlement for this operation is substituted by verifiable
        /// <br/>evidence (JWT) associated to the health record owner acting as health record owner's explicit
        /// <br/>permission for the requesting user to establish a new entitlement.
        /// <br/>
        /// <br/>The operation shall count the number of failed comparison check of _hcv_ values 
        /// <br/>and also _kvnr_ for each user (telematik-id).
        /// <br/>In case of more than 5 failed comparison checks (5 checks for each counter) within 1 hour
        /// <br/>the operation shall be aborted. 
        /// <br/>
        /// <br/>The received JWT shall be passed to the HSM for entitlement verification, using rule _rr3_.
        /// <br/>
        /// <br/>The HSM rule verifies JWT signature, _actorID_, encryption of _kvnr_ (associated health record) and claims
        /// <br/>in a CMAC secured result _actorId_, _kvnr_ and _validTo_ (_validTo_ is applied by HSM according to 
        /// <br/>user role). HSM verifies also consistence of requestor properties vs claims in JWT signature
        /// <br/>and audit evidence.
        /// <br/>
        /// <br/>The entitlement management enforces the requirements for rate limiting.
        /// <br/>
        /// <br/>The CMAC secured result shall be completed with the following data:
        /// <br/>- _oid_ of the entitled user (from JWT or request context)
        /// <br/>- _displayName_ of the entitled user (from JWT or request context)
        /// <br/>- _issued-at_ current system time
        /// <br/>- _issued-actorId_ of requestor (from request context)
        /// <br/>- _issued-displayName_ of requestor (from request context)
        /// <br/>
        /// <br/>The completed entitlement shall NOT be stored and cause operation abortion in cases:
        /// <br/>- _oid_ is not in the list of allowed usergroups (role)
        /// <br/>- _actorId_ is referenced by a Blocked User Policy assignment
        /// <br/>- _actorId_ is referenced by a Deny List assignment
        /// <br/>
        /// <br/>- if _enforce_hcv_check_ == true or _hcv_ value of JWT and _hcv_ from hsm rule _rr3_ are both available:
        /// <br/>   - _hcv_ value of JWT does not match _hcv_ from hsm rule _rr3_
        /// <br/>- _x-insurantid_ does not match _kvnr_ from hsm rule _rr3_
        /// <br/>
        /// <br/>If an existing and stored entitlement addressing the same user exists and if this stored
        /// <br/>entitlement indicates a _validTo_ which is in the future of the new entitlement's _validTo_, 
        /// <br/>then the existing entitlement shall be kept, else the completed new entitlement shall be stored, 
        /// <br/>encrypted by SecureAdminStorageKey of the health record.&lt;/br&gt;
        /// <br/>If the new entitlement is stored, a possibly existing entitlement is deleted automatically.&lt;/br&gt;
        /// <br/>All above are success cases for this operation.
        /// <br/>The response of the operation shall return the current _validTo_ setting as information.
        /// <br/>
        /// <br/>The addressed user of the request shall be entitled after successful operation.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 201 || even if an existing entitlement is kept due to longer validity |
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Requestor role is not in the list of allowed usergroups | 403 | invalidOid ||
        /// <br/>| Token verification failed | 403 | invalidToken ||
        /// <br/>| Health record does not exist | 404 | noHealthRecord | _insurantid_ unknown |
        /// <br/>| Health record is not in state ACTIVATED | 409 | statusMismatch | (see 'Retry interval') |
        /// <br/>| hcv value of jwt does not exist | 409 | hcvMissing ||
        /// <br/>| request claims _actorId_ and _actorId_ is referenced by a Blocked User Policy assignment | 409 | requestMismatch ||
        /// <br/>| request claims _actorId_ and _actorId_ is referenced by a Deny List assignment | 409 | requestMismatch ||
        /// <br/>| Rate limiting | 423 | locked||
        /// <br/>| to many failed attempts | 423 | locked | _hcv_ check limit |
        /// <br/>| to many failed attempts | 423 | locked | _kvnr_ check limit |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/>&lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| The valid and completed entitlement is stored in SecureDataStorage | a possible existing entitlement with earlier _validTo_ is replaced |
        /// <br/>| The user addressed by the new entitlement is entitled | successful operation only |
        /// <br/>| A log-entry for the operation exists | successful operation only |
        /// <br/>| The raw-data of the operation is collected and associated to _useragent_ | for any operation result according to gemSpec_Perf UC_A2.1 |
        /// </remarks>
        /// <param name="x_insurantid">Health Record Identifier.</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>Created. User is entitled</returns>
        /// <exception cref="EntitlementManagementException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<ValidToResponseType> SetEntitlementPsAsync(EntitlementRequestType body, string x_insurantid, string x_useragent, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (x_insurantid == null)
                        throw new System.ArgumentNullException("x_insurantid");
                    request_.Headers.TryAddWithoutValidation("x-insurantid", ConvertToString(x_insurantid, System.Globalization.CultureInfo.InvariantCulture));

                    if (x_useragent == null)
                        throw new System.ArgumentNullException("x_useragent");
                    request_.Headers.TryAddWithoutValidation("x-useragent", ConvertToString(x_useragent, System.Globalization.CultureInfo.InvariantCulture));
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "epa/basic/api/v1/ps/entitlements"
                    urlBuilder_.Append("epa/basic/api/v1/ps/entitlements");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 201)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ValidToResponseType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Bad Request.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Forbidden.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Not found.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Conflict.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 423)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Locked.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new EntitlementManagementException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// (getBlockedUserPolicyAssignments) get a list of blocked users
        /// </summary>
        /// <remarks>
        /// Get a list of actual set assignments of the blocked user policy.&lt;/br&gt;
        /// <br/>This operation is limited to entitled users of role oid_versicherter and oid_ombudsstelle.
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The returned list shall contain only all assignments of the blocked user policy.&lt;/br&gt;
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 200 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Device registration does not exist | 403 | unregisteredDevice | if requestor role is oid_versicherter only |
        /// <br/>| Requestor has no valid entitlement | 403 | notEntitled ||
        /// <br/>| Requestor role is not oid_versicherter_ or _oid_ombudsstelle_| 403 | invalidOid ||
        /// <br/>| Health record does not exist | 404 | noHealthRecord | _insurantid_ unknown |
        /// <br/>| Health record is not in state ACTIVATED | 409 | statusMismatch | (see 'Retry interval') |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| none ||
        /// </remarks>
        /// <param name="x_insurantid">Health Record Identifier.</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>Ok. Returns a list of policy assignments</returns>
        /// <exception cref="EntitlementManagementException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response2> GetBlockedUserPolicyAssignmentsAsync(string x_insurantid, string x_useragent)
        {
            return GetBlockedUserPolicyAssignmentsAsync(x_insurantid, x_useragent, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// (getBlockedUserPolicyAssignments) get a list of blocked users
        /// </summary>
        /// <remarks>
        /// Get a list of actual set assignments of the blocked user policy.&lt;/br&gt;
        /// <br/>This operation is limited to entitled users of role oid_versicherter and oid_ombudsstelle.
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The returned list shall contain only all assignments of the blocked user policy.&lt;/br&gt;
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 200 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Device registration does not exist | 403 | unregisteredDevice | if requestor role is oid_versicherter only |
        /// <br/>| Requestor has no valid entitlement | 403 | notEntitled ||
        /// <br/>| Requestor role is not oid_versicherter_ or _oid_ombudsstelle_| 403 | invalidOid ||
        /// <br/>| Health record does not exist | 404 | noHealthRecord | _insurantid_ unknown |
        /// <br/>| Health record is not in state ACTIVATED | 409 | statusMismatch | (see 'Retry interval') |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| none ||
        /// </remarks>
        /// <param name="x_insurantid">Health Record Identifier.</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>Ok. Returns a list of policy assignments</returns>
        /// <exception cref="EntitlementManagementException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response2> GetBlockedUserPolicyAssignmentsAsync(string x_insurantid, string x_useragent, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (x_insurantid == null)
                        throw new System.ArgumentNullException("x_insurantid");
                    request_.Headers.TryAddWithoutValidation("x-insurantid", ConvertToString(x_insurantid, System.Globalization.CultureInfo.InvariantCulture));

                    if (x_useragent == null)
                        throw new System.ArgumentNullException("x_useragent");
                    request_.Headers.TryAddWithoutValidation("x-useragent", ConvertToString(x_useragent, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "epa/basic/api/v1/blockedusers"
                    urlBuilder_.Append("epa/basic/api/v1/blockedusers");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response2>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Bad Request.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Forbidden.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Not found.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Conflict.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new EntitlementManagementException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// (setBlockedUserPolicyAssignment) add a user to the blocked user policy
        /// </summary>
        /// <remarks>
        /// Set a new assignment for the blocked user policy.&lt;/br&gt;
        /// <br/>The user addressed by the policy assignment can not be entitled by any means, a possibly existing 
        /// <br/>entitlement is lost.&lt;/br&gt;
        /// <br/>This operation is limited to entitled users of role oid_versicherter and oid_ombudsstelle.
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client shall set assignments for users of the allowed roles for 
        /// <br/>user blocking only.&lt;/br&gt;
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>A valid new assignment shall be added to the blocked user policy.
        /// <br/>
        /// <br/>Each new valid assigment shall be extended by a timestamp (_at_ = current date and time)
        /// <br/>by the server.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 201 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Device registration does not exist | 403 | unregisteredDevice | if requestor role is oid_versicherter only |
        /// <br/>| Requestor has no valid entitlement | 403 | notEntitled ||
        /// <br/>| Requestor role is not _oid_versicherter_ or _oid_ombudsstelle_ | 403 | invalidOid ||
        /// <br/>| Health record does not exist | 404 | noHealthRecord | _insurantid_ unknown |
        /// <br/>| Health record is not in state ACTIVATED | 409 | statusMismatch | (see 'Retry interval') |
        /// <br/>| The assignment parameter _oid_ is not in the list of allowd oids | 409 | requestMismatch ||
        /// <br/>| The assignment does yet exist (same _actorId_) | 409 | requestMismatch | avoid duplicates |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| The policy assignment is extended with the timestamp and stored in SecureDataStorage ||
        /// <br/>| An existing entitlement for the addressed user of the assignment is deleted ||
        /// <br/>| An eMail is sent to the insurant, including information about the blocked user policy change| if eMail address is available |
        /// <br/>| A log-entry for the operation exists | all operation results |
        /// </remarks>
        /// <param name="x_insurantid">Health Record Identifier.</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>Created</returns>
        /// <exception cref="EntitlementManagementException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<BlockedUserPolicyAssignmentResponseType> SetBlockedUserPolicyAssignmentAsync(BlockedUserPolicyAssignmentType body, string x_insurantid, string x_useragent)
        {
            return SetBlockedUserPolicyAssignmentAsync(body, x_insurantid, x_useragent, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// (setBlockedUserPolicyAssignment) add a user to the blocked user policy
        /// </summary>
        /// <remarks>
        /// Set a new assignment for the blocked user policy.&lt;/br&gt;
        /// <br/>The user addressed by the policy assignment can not be entitled by any means, a possibly existing 
        /// <br/>entitlement is lost.&lt;/br&gt;
        /// <br/>This operation is limited to entitled users of role oid_versicherter and oid_ombudsstelle.
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client shall set assignments for users of the allowed roles for 
        /// <br/>user blocking only.&lt;/br&gt;
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>A valid new assignment shall be added to the blocked user policy.
        /// <br/>
        /// <br/>Each new valid assigment shall be extended by a timestamp (_at_ = current date and time)
        /// <br/>by the server.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 201 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Device registration does not exist | 403 | unregisteredDevice | if requestor role is oid_versicherter only |
        /// <br/>| Requestor has no valid entitlement | 403 | notEntitled ||
        /// <br/>| Requestor role is not _oid_versicherter_ or _oid_ombudsstelle_ | 403 | invalidOid ||
        /// <br/>| Health record does not exist | 404 | noHealthRecord | _insurantid_ unknown |
        /// <br/>| Health record is not in state ACTIVATED | 409 | statusMismatch | (see 'Retry interval') |
        /// <br/>| The assignment parameter _oid_ is not in the list of allowd oids | 409 | requestMismatch ||
        /// <br/>| The assignment does yet exist (same _actorId_) | 409 | requestMismatch | avoid duplicates |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| The policy assignment is extended with the timestamp and stored in SecureDataStorage ||
        /// <br/>| An existing entitlement for the addressed user of the assignment is deleted ||
        /// <br/>| An eMail is sent to the insurant, including information about the blocked user policy change| if eMail address is available |
        /// <br/>| A log-entry for the operation exists | all operation results |
        /// </remarks>
        /// <param name="x_insurantid">Health Record Identifier.</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>Created</returns>
        /// <exception cref="EntitlementManagementException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<BlockedUserPolicyAssignmentResponseType> SetBlockedUserPolicyAssignmentAsync(BlockedUserPolicyAssignmentType body, string x_insurantid, string x_useragent, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (x_insurantid == null)
                        throw new System.ArgumentNullException("x_insurantid");
                    request_.Headers.TryAddWithoutValidation("x-insurantid", ConvertToString(x_insurantid, System.Globalization.CultureInfo.InvariantCulture));

                    if (x_useragent == null)
                        throw new System.ArgumentNullException("x_useragent");
                    request_.Headers.TryAddWithoutValidation("x-useragent", ConvertToString(x_useragent, System.Globalization.CultureInfo.InvariantCulture));
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "epa/basic/api/v1/blockedusers"
                    urlBuilder_.Append("epa/basic/api/v1/blockedusers");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 201)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BlockedUserPolicyAssignmentResponseType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Bad Request.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Forbidden.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Not found.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Conflict.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new EntitlementManagementException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// (getBlockedUserPolicyAssignment) get a particular blocked user
        /// </summary>
        /// <remarks>
        /// Get one particular assignment of the blocked user policy.&lt;/br&gt;
        /// <br/>This operation is limited to entitled users of role oid_versicherter and oid_ombudsstelle .
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>no recommendations.
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The addressed assigment shall be returned.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 200 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Device registration does not exist | 403 | unregisteredDevice | if requestor role is oid_versicherter only |
        /// <br/>| Requestor has no valid entitlement | 403 | notEntitled ||
        /// <br/>| Requestor role is not oid_versicherter_ or _oid_ombudsstelle_ | 403 | invalidOid ||
        /// <br/>| Health record does not exist | 404 | noHealthRecord | _insurantid_ unknown |
        /// <br/>| Resource for _telematikid_ does not exist | 404 | noResource ||
        /// <br/>| Health record is not in state ACTIVATED | 409 | statusMismatch | (see 'Retry interval') |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| none ||
        /// </remarks>
        /// <param name="x_insurantid">Health Record Identifier.</param>
        /// <param name="telematikid">TelematikID</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>Ok.</returns>
        /// <exception cref="EntitlementManagementException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<BlockedUserPolicyAssignmentResponseType> GetBlockedUserPolicyAssignmentAsync(string x_insurantid, string telematikid, string x_useragent)
        {
            return GetBlockedUserPolicyAssignmentAsync(x_insurantid, telematikid, x_useragent, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// (getBlockedUserPolicyAssignment) get a particular blocked user
        /// </summary>
        /// <remarks>
        /// Get one particular assignment of the blocked user policy.&lt;/br&gt;
        /// <br/>This operation is limited to entitled users of role oid_versicherter and oid_ombudsstelle .
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>no recommendations.
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The addressed assigment shall be returned.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 200 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Device registration does not exist | 403 | unregisteredDevice | if requestor role is oid_versicherter only |
        /// <br/>| Requestor has no valid entitlement | 403 | notEntitled ||
        /// <br/>| Requestor role is not oid_versicherter_ or _oid_ombudsstelle_ | 403 | invalidOid ||
        /// <br/>| Health record does not exist | 404 | noHealthRecord | _insurantid_ unknown |
        /// <br/>| Resource for _telematikid_ does not exist | 404 | noResource ||
        /// <br/>| Health record is not in state ACTIVATED | 409 | statusMismatch | (see 'Retry interval') |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| none ||
        /// </remarks>
        /// <param name="x_insurantid">Health Record Identifier.</param>
        /// <param name="telematikid">TelematikID</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>Ok.</returns>
        /// <exception cref="EntitlementManagementException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<BlockedUserPolicyAssignmentResponseType> GetBlockedUserPolicyAssignmentAsync(string x_insurantid, string telematikid, string x_useragent, System.Threading.CancellationToken cancellationToken)
        {
            if (telematikid == null)
                throw new System.ArgumentNullException("telematikid");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (x_insurantid == null)
                        throw new System.ArgumentNullException("x_insurantid");
                    request_.Headers.TryAddWithoutValidation("x-insurantid", ConvertToString(x_insurantid, System.Globalization.CultureInfo.InvariantCulture));

                    if (x_useragent == null)
                        throw new System.ArgumentNullException("x_useragent");
                    request_.Headers.TryAddWithoutValidation("x-useragent", ConvertToString(x_useragent, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "epa/basic/api/v1/blockedusers/{telematikid}"
                    urlBuilder_.Append("epa/basic/api/v1/blockedusers/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(telematikid, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<BlockedUserPolicyAssignmentResponseType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Bad Request.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Forbidden.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Not found.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Conflict.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new EntitlementManagementException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// (deleteBlockedUserPolicyAssignment) remove a user from the blocked user policy
        /// </summary>
        /// <remarks>
        /// Delete one existing assignment of the blocked user policy.&lt;/br&gt;
        /// <br/>This operation is limited to entitled users of role oid_versicherter and oid_ombudsstelle.
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>no recommendations.
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The addressed assigment shall be removed from the policy.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 204 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Device registration does not exist | 403 | unregisteredDevice | if requestor role is oid_versicherter only |
        /// <br/>| Requestor has no valid entitlement | 403 | notEntitled ||
        /// <br/>| Requestor role is not _oid_versicherter_ or _oid_ombudsstelle_| 403 | invalidOid ||
        /// <br/>| Health record does not exist | 404 | noHealthRecord | _insurantid_ unknown |
        /// <br/>| Assignment (_telematikid_) does not exist | 404 | noResource ||
        /// <br/>| Health record is not in state ACTIVATED | 409 | statusMismatch | (see 'Retry interval') |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| The addressed assignment is removed from the associated policy ||
        /// <br/>| An eMail is sent to the insurant, including information about the blocked user policy change| if eMail address is available |
        /// <br/>| A log-entry for the operation exists | all operation results |
        /// </remarks>
        /// <param name="x_insurantid">Health Record Identifier.</param>
        /// <param name="telematikid">TelematikID</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK. Assignment deleted</returns>
        /// <exception cref="EntitlementManagementException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task DeleteBlockedUserPolicyAssignmentAsync(string x_insurantid, string telematikid, string x_useragent)
        {
            return DeleteBlockedUserPolicyAssignmentAsync(x_insurantid, telematikid, x_useragent, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// (deleteBlockedUserPolicyAssignment) remove a user from the blocked user policy
        /// </summary>
        /// <remarks>
        /// Delete one existing assignment of the blocked user policy.&lt;/br&gt;
        /// <br/>This operation is limited to entitled users of role oid_versicherter and oid_ombudsstelle.
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>no recommendations.
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The addressed assigment shall be removed from the policy.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 204 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Device registration does not exist | 403 | unregisteredDevice | if requestor role is oid_versicherter only |
        /// <br/>| Requestor has no valid entitlement | 403 | notEntitled ||
        /// <br/>| Requestor role is not _oid_versicherter_ or _oid_ombudsstelle_| 403 | invalidOid ||
        /// <br/>| Health record does not exist | 404 | noHealthRecord | _insurantid_ unknown |
        /// <br/>| Assignment (_telematikid_) does not exist | 404 | noResource ||
        /// <br/>| Health record is not in state ACTIVATED | 409 | statusMismatch | (see 'Retry interval') |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| The addressed assignment is removed from the associated policy ||
        /// <br/>| An eMail is sent to the insurant, including information about the blocked user policy change| if eMail address is available |
        /// <br/>| A log-entry for the operation exists | all operation results |
        /// </remarks>
        /// <param name="x_insurantid">Health Record Identifier.</param>
        /// <param name="telematikid">TelematikID</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK. Assignment deleted</returns>
        /// <exception cref="EntitlementManagementException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task DeleteBlockedUserPolicyAssignmentAsync(string x_insurantid, string telematikid, string x_useragent, System.Threading.CancellationToken cancellationToken)
        {
            if (telematikid == null)
                throw new System.ArgumentNullException("telematikid");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (x_insurantid == null)
                        throw new System.ArgumentNullException("x_insurantid");
                    request_.Headers.TryAddWithoutValidation("x-insurantid", ConvertToString(x_insurantid, System.Globalization.CultureInfo.InvariantCulture));

                    if (x_useragent == null)
                        throw new System.ArgumentNullException("x_useragent");
                    request_.Headers.TryAddWithoutValidation("x-useragent", ConvertToString(x_useragent, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("DELETE");

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "epa/basic/api/v1/blockedusers/{telematikid}"
                    urlBuilder_.Append("epa/basic/api/v1/blockedusers/");
                    urlBuilder_.Append(System.Uri.EscapeDataString(ConvertToString(telematikid, System.Globalization.CultureInfo.InvariantCulture)));

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Bad Request.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Forbidden.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Not found.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Conflict.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new EntitlementManagementException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new EntitlementManagementException<ErrorType>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new EntitlementManagementException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Threading.CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = System.Text.Json.JsonSerializer.Deserialize<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (System.Text.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new EntitlementManagementException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    {
                        var typedBody = await System.Text.Json.JsonSerializer.DeserializeAsync<T>(responseStream, JsonSerializerSettings, cancellationToken).ConfigureAwait(false);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (System.Text.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new EntitlementManagementException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is System.Enum)
            {
                var name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = System.Convert.ToString(System.Convert.ChangeType(value, System.Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return System.Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value is string[])
            {
                return string.Join(",", (string[])value);
            }
            else if (value.GetType().IsArray)
            {
                var valueArray = (System.Array)value;
                var valueTextArray = new string[valueArray.Length];
                for (var i = 0; i < valueArray.Length; i++)
                {
                    valueTextArray[i] = ConvertToString(valueArray.GetValue(i), cultureInfo);
                }
                return string.Join(",", valueTextArray);
            }

            var result = System.Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ActorIdType
    {

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// "A JSON Web Token (JWT) with following format build according to RFC-7515:&lt;/br&gt;
    /// <br/>base64url (protected_header) + '.' + base64url (payload) + '.' + base64url (signature)"&lt;/br&gt;
    /// <br/>- Content for ePA-FdV originated entitlements:&lt;/br&gt;
    /// <br/>  - protected_header contains:
    /// <br/>    - "typ": "JWT"
    /// <br/>    - "alg": "ES256" 
    /// <br/>    - "x5c": signature certificate (C.CH.SIG)
    /// <br/>  - payload claims:
    /// <br/>    - "iat": issued at timestamp
    /// <br/>    - "exp": expiry timestamp (always iat + 20min)
    /// <br/>    - "insurantId": the health record identifier this entitlement is assoctiated to
    /// <br/>    - "actorId": Telematik-Id or KVNR
    /// <br/>    - "oid": value of professionOID
    /// <br/>    - "displayName": name according to actorId
    /// <br/>    - "validTo": Expiry date-time of entitlement in format according to rfc3339
    /// <br/>  - signature contains token signature
    /// <br/>- Content for PS originated entitlements:&lt;/br&gt;
    /// <br/>  - protected_header contains:
    /// <br/>    - "typ": "JWT"
    /// <br/>    - "alg": "ES256" or "PS256"
    /// <br/>    - "x5c": signature certificate (C.HCI.AUT from smc-b of requestor)
    /// <br/>  - payload claims:
    /// <br/>    - "iat": issued at timestamp
    /// <br/>    - "exp": expiry timestamp (always iat + 20min)
    /// <br/>    - "auditEvidence": proof-of-audit received from VSDM Service ('Prüfziffer des VSDM Prüfungsnachweises')
    /// <br/>    - "hcv": optional if _enforce_hcv_check_ == false; hash check value generated by PS according to A_27352-*
    /// <br/>  - signature contains token signature
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EntitlementRequestType
    {

        [System.Text.Json.Serialization.JsonPropertyName("jwt")]
        public string Jwt { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EntitlementRequestRepType : EntitlementRequestType
    {

        [System.Text.Json.Serialization.JsonPropertyName("email")]
        public string Email { get; set; }

    }

    /// <summary>
    /// Properties of one specific entitlement
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EntitlementClaimsResponseType
    {

        [System.Text.Json.Serialization.JsonPropertyName("actorId")]
        public string ActorId { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("oid")]
        public string Oid { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("displayName")]
        public string DisplayName { get; set; }

        /// <summary>
        /// End of validity
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("validTo")]
        public System.DateTime ValidTo { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("issued")]
        public Issued Issued { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// validTo element of one specific entitlement
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ValidToResponseType
    {
        /// <summary>
        /// End of validity
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("validTo")]
        public System.DateTime ValidTo { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Properties of one specific user
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BlockedUserPolicyAssignmentType
    {

        [System.Text.Json.Serialization.JsonPropertyName("actorId")]
        public string ActorId { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("oid")]
        public string Oid { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("displayName")]
        public string DisplayName { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BlockedUserPolicyAssignmentResponseType : BlockedUserPolicyAssignmentType
    {
        /// <summary>
        /// Creation timestamp
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("at")]
        public System.DateTime At { get; set; }

    }

    /// <summary>
    /// Error object with additional information about the occurred error
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ErrorType
    {
        /// <summary>
        /// Error condition specifier
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("errorCode")]
        public string ErrorCode { get; set; }

        /// <summary>
        /// Additional details regarding the error condition (if applicable)
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("errorDetail")]
        public string ErrorDetail { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Body
    {

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Response
    {

        [System.Text.Json.Serialization.JsonPropertyName("data")]
        public System.Collections.Generic.ICollection<EntitlementClaimsResponseType> Data { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Response2
    {

        [System.Text.Json.Serialization.JsonPropertyName("data")]
        public System.Collections.Generic.ICollection<BlockedUserPolicyAssignmentResponseType> Data { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Issued
    {
        /// <summary>
        /// Creation time timestamp
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("at")]
        public System.DateTime At { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("actorId")]
        public string ActorId { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("displayName")]
        public string DisplayName { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }



    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EntitlementManagementException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public EntitlementManagementException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException)
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + ((response == null) ? "(null)" : response.Substring(0, response.Length >= 512 ? 512 : response.Length)), innerException)
        {
            StatusCode = statusCode;
            Response = response;
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class EntitlementManagementException<TResult> : EntitlementManagementException
    {
        public TResult Result { get; private set; }

        public EntitlementManagementException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException)
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}

#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625