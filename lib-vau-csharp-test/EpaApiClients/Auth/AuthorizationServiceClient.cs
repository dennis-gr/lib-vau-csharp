//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 612 // Disable "CS0612 '...' is obsolete"
#pragma warning disable 649 // Disable "CS0649 Field is never assigned to, and will always have its default value null"
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"
#pragma warning disable 8600 // Disable "CS8600 Converting null literal or possible null value to non-nullable type"
#pragma warning disable 8602 // Disable "CS8602 Dereference of a possibly null reference"
#pragma warning disable 8603 // Disable "CS8603 Possible null reference return"
#pragma warning disable 8604 // Disable "CS8604 Possible null reference argument for parameter"
#pragma warning disable 8625 // Disable "CS8625 Cannot convert null literal to non-nullable reference type"
#pragma warning disable 8765 // Disable "CS8765 Nullability of type of parameter doesn't match overridden member (possibly because of nullability attributes)."

namespace lib_vau_csharp_test.EpaApiClients.Auth
{
    using System = global::System;

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial interface IAuthorizationServiceClient
    {
        /// <summary>
        /// (getFHIRVZDtoken) Get the FHIR VZD search access-token
        /// </summary>
        /// <remarks>
        /// Get the directory service (FHIR VZD) search-token of the health record system.
        /// <br/>This operation is limited to authenticated users (IDP) only.
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client shall use the provided search access-token for directory service queries instead of an own, individual
        /// <br/>registration.
        /// <br/>
        /// <br/>**Provider**:
        /// <br/>The authorization service shall return the search access-token as received from the FHIR Directory.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 200 |||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| none ||
        /// </remarks>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK</returns>
        /// <exception cref="AuthorizationServiceException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SearchAccessTokenType> GetFHIRVZDtokenAsync(string x_useragent);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// (getFHIRVZDtoken) Get the FHIR VZD search access-token
        /// </summary>
        /// <remarks>
        /// Get the directory service (FHIR VZD) search-token of the health record system.
        /// <br/>This operation is limited to authenticated users (IDP) only.
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client shall use the provided search access-token for directory service queries instead of an own, individual
        /// <br/>registration.
        /// <br/>
        /// <br/>**Provider**:
        /// <br/>The authorization service shall return the search access-token as received from the FHIR Directory.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 200 |||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| none ||
        /// </remarks>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK</returns>
        /// <exception cref="AuthorizationServiceException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<SearchAccessTokenType> GetFHIRVZDtokenAsync(string x_useragent, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// (getNonce) Generate nonce (random value) for an authorization request
        /// </summary>
        /// <remarks>
        /// A nonce is a generated unique random value. This operation provides the nonce
        /// <br/>for the client (attestation).&lt;/br&gt; 
        /// <br/>Remark: This is NOT the nonce used by the authorization
        /// <br/>service towards the IDP in an IDP flow! 
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client shall sign the received nonce. The signed nonce shall be used as client 
        /// <br/>attestation for the authorization requests finalization (_sendAuthCodeSC_).
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The nonce shall be stored for later comparison in a subsequent _sendAuthCodeSc_ operation.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 200 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| The nonce is kept for subsequent _sendAuthCodeSC_ operation ||
        /// </remarks>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>Ok.</returns>
        /// <exception cref="AuthorizationServiceException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response> GetNonceAsync(string x_useragent);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// (getNonce) Generate nonce (random value) for an authorization request
        /// </summary>
        /// <remarks>
        /// A nonce is a generated unique random value. This operation provides the nonce
        /// <br/>for the client (attestation).&lt;/br&gt; 
        /// <br/>Remark: This is NOT the nonce used by the authorization
        /// <br/>service towards the IDP in an IDP flow! 
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client shall sign the received nonce. The signed nonce shall be used as client 
        /// <br/>attestation for the authorization requests finalization (_sendAuthCodeSC_).
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The nonce shall be stored for later comparison in a subsequent _sendAuthCodeSc_ operation.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 200 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| The nonce is kept for subsequent _sendAuthCodeSC_ operation ||
        /// </remarks>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>Ok.</returns>
        /// <exception cref="AuthorizationServiceException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response> GetNonceAsync(string x_useragent, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// (sendAuthorizationRequestSC) Send authorization request
        /// </summary>
        /// <remarks>
        /// Request authorization for a smartcard (SMC-B) based client.
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client will receive a well prepared redirection uri and parameters for the authoriation request
        /// <br/>towards the authenticator. A client shall invoke the authenticator and IDP flow to revceive an 
        /// <br/>authorization code for the subsequent _sendAuthCodeSC_ operation.
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The authorization server shall prepare a complete redirection uri and authorization request parameters 
        /// <br/>(PAR-URI) for the central smartcard IDP. 
        /// <br/>This operation shall be rejected if the corresponding user session is already authorized. Repeated authorization
        /// <br/>attempts are not supported.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 302 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Invalid request | 403 | invalAuth | includes any error of Authorization Service which is not mapped to 500 internal Server error |
        /// <br/>| Repeated authorization attempt | 409 | statusMismatch | when user session is already authorized only |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| none ||
        /// </remarks>
        /// <param name="x_useragent">user agent information</param>
        /// <exception cref="AuthorizationServiceException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SendAuthorizationRequestSCAsync(string x_useragent);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// (sendAuthorizationRequestSC) Send authorization request
        /// </summary>
        /// <remarks>
        /// Request authorization for a smartcard (SMC-B) based client.
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client will receive a well prepared redirection uri and parameters for the authoriation request
        /// <br/>towards the authenticator. A client shall invoke the authenticator and IDP flow to revceive an 
        /// <br/>authorization code for the subsequent _sendAuthCodeSC_ operation.
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The authorization server shall prepare a complete redirection uri and authorization request parameters 
        /// <br/>(PAR-URI) for the central smartcard IDP. 
        /// <br/>This operation shall be rejected if the corresponding user session is already authorized. Repeated authorization
        /// <br/>attempts are not supported.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 302 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Invalid request | 403 | invalAuth | includes any error of Authorization Service which is not mapped to 500 internal Server error |
        /// <br/>| Repeated authorization attempt | 409 | statusMismatch | when user session is already authorized only |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| none ||
        /// </remarks>
        /// <param name="x_useragent">user agent information</param>
        /// <exception cref="AuthorizationServiceException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SendAuthorizationRequestSCAsync(string x_useragent, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// (sendAuthCodeSC) Send authorization code
        /// </summary>
        /// <remarks>
        /// After successful user authentication the authorization code grant was returned to the authorization 
        /// <br/>service, that is exchanged for an ID token at the IDP's token endpoint using this operation.
        /// <br/>This operation is limited to users of the "Allowed usergroups for Authorization SMC-B"
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client shall submit the authorization code received from the authenticator and the client attestation
        /// <br/>(signed nonce)
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The authorization service shall use the authorization code to prepare a token request for the IDP and receive
        /// <br/>the encrypted ID-Token in return. 
        /// <br/>The received ID-Token shall be validated with HSM rule 'rr0'. The resulting HSM-ID-Token shall be added to the user session.
        /// <br/>
        /// <br/>The authorization service shall further validate the ID-token against the stored nonce (from a preceding _getNonce_ operation)
        /// <br/>and the client attestation:
        /// <br/>- _clientAttest_ is valid if
        /// <br/>  - signature is valid
        /// <br/>  - "exp" expiration_time is a timestamp 20 minutes in the future "iat".
        /// <br/>  - user has role as in "Allowed usergroups for Authorization SMC-B" (from signature cert)
        /// <br/>- stored nonce shall not be outdated
        /// <br/>- stored nonce shall match client attestation nonce
        /// <br/>- Telematik-Id of client attestation (from signature cert) shall match the telematik-id claim of the ID-Token 
        /// <br/>
        /// <br/>The user session of the client shall be closed and all session related data shall be deleted in case operation is not successful.
        /// <br/>
        /// <br/>The nonce shall be discarded, i.e. reuse of a client attestation for user session establishment shall be rejected. 
        /// <br/>
        /// <br/>The VAU user preudonym as generated for the vau-channel (see: vau protocol) shall be returned in a successful operation response.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 200 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Invalid request | 403 | invalAuth | includes any error of Authorization Service which are not mapped to 500 internal Server error |
        /// <br/>| No or outdated nonce | 409 | statusMismatch | No preceding _getNonce_ call or stored nonce outdated/invalid |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| The nonce is discarded ||
        /// <br/>| User session has valid HSM-ID-Token for requesting client (telematik-id) | successful operation only |
        /// <br/>| User session and temporary data is deleted | failed operation only |
        /// </remarks>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK, Successful login</returns>
        /// <exception cref="AuthorizationServiceException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response2> SendAuthCodeSCAsync(SendAuthCodeSCtype body, string x_useragent);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// (sendAuthCodeSC) Send authorization code
        /// </summary>
        /// <remarks>
        /// After successful user authentication the authorization code grant was returned to the authorization 
        /// <br/>service, that is exchanged for an ID token at the IDP's token endpoint using this operation.
        /// <br/>This operation is limited to users of the "Allowed usergroups for Authorization SMC-B"
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client shall submit the authorization code received from the authenticator and the client attestation
        /// <br/>(signed nonce)
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The authorization service shall use the authorization code to prepare a token request for the IDP and receive
        /// <br/>the encrypted ID-Token in return. 
        /// <br/>The received ID-Token shall be validated with HSM rule 'rr0'. The resulting HSM-ID-Token shall be added to the user session.
        /// <br/>
        /// <br/>The authorization service shall further validate the ID-token against the stored nonce (from a preceding _getNonce_ operation)
        /// <br/>and the client attestation:
        /// <br/>- _clientAttest_ is valid if
        /// <br/>  - signature is valid
        /// <br/>  - "exp" expiration_time is a timestamp 20 minutes in the future "iat".
        /// <br/>  - user has role as in "Allowed usergroups for Authorization SMC-B" (from signature cert)
        /// <br/>- stored nonce shall not be outdated
        /// <br/>- stored nonce shall match client attestation nonce
        /// <br/>- Telematik-Id of client attestation (from signature cert) shall match the telematik-id claim of the ID-Token 
        /// <br/>
        /// <br/>The user session of the client shall be closed and all session related data shall be deleted in case operation is not successful.
        /// <br/>
        /// <br/>The nonce shall be discarded, i.e. reuse of a client attestation for user session establishment shall be rejected. 
        /// <br/>
        /// <br/>The VAU user preudonym as generated for the vau-channel (see: vau protocol) shall be returned in a successful operation response.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 200 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Invalid request | 403 | invalAuth | includes any error of Authorization Service which are not mapped to 500 internal Server error |
        /// <br/>| No or outdated nonce | 409 | statusMismatch | No preceding _getNonce_ call or stored nonce outdated/invalid |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| The nonce is discarded ||
        /// <br/>| User session has valid HSM-ID-Token for requesting client (telematik-id) | successful operation only |
        /// <br/>| User session and temporary data is deleted | failed operation only |
        /// </remarks>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK, Successful login</returns>
        /// <exception cref="AuthorizationServiceException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response2> SendAuthCodeSCAsync(SendAuthCodeSCtype body, string x_useragent, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// (getFreshnessParameter) Get freshness parameter for a bearer token
        /// </summary>
        /// <remarks>
        /// Get a new freshness parameter for a new bearer token for the authorization by bearer token.
        /// <br/>
        /// <br/>**Client**&lt;/br&gt;
        /// <br/>The ePrescription backend shall use the freshness parameter for a signed JWT (bearer token) according to requirement gemSpec_Aktensystem_ePAfuerAlle, A_25165*.
        /// <br/>
        /// <br/>**Provider**&lt;/br&gt;
        /// <br/>The returned freshness parameter shall follow the requirements in gemSpec_Krypt, A_24658* and be verifiable by HSM rule 'rr0'. 
        /// <br/>
        /// <br/> | Conditions | Status code | Error code | Remarks |
        /// <br/> |------------|-------------|------------|---------|
        /// <br/> | Successful operation | 200 |||
        /// <br/> | Any other error | 500 | internalError ||
        /// <br/>
        /// <br/>  &lt;/br&gt;
        /// <br/> | Postconditions                        | Remarks |
        /// <br/> |---------------------------------------|---------|
        /// <br/> | none ||
        /// </remarks>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK</returns>
        /// <exception cref="AuthorizationServiceException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response3> GetFreshnessParameterAsync(string x_useragent);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// (getFreshnessParameter) Get freshness parameter for a bearer token
        /// </summary>
        /// <remarks>
        /// Get a new freshness parameter for a new bearer token for the authorization by bearer token.
        /// <br/>
        /// <br/>**Client**&lt;/br&gt;
        /// <br/>The ePrescription backend shall use the freshness parameter for a signed JWT (bearer token) according to requirement gemSpec_Aktensystem_ePAfuerAlle, A_25165*.
        /// <br/>
        /// <br/>**Provider**&lt;/br&gt;
        /// <br/>The returned freshness parameter shall follow the requirements in gemSpec_Krypt, A_24658* and be verifiable by HSM rule 'rr0'. 
        /// <br/>
        /// <br/> | Conditions | Status code | Error code | Remarks |
        /// <br/> |------------|-------------|------------|---------|
        /// <br/> | Successful operation | 200 |||
        /// <br/> | Any other error | 500 | internalError ||
        /// <br/>
        /// <br/>  &lt;/br&gt;
        /// <br/> | Postconditions                        | Remarks |
        /// <br/> |---------------------------------------|---------|
        /// <br/> | none ||
        /// </remarks>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK</returns>
        /// <exception cref="AuthorizationServiceException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response3> GetFreshnessParameterAsync(string x_useragent, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// (sendAuthorizationRequestBearerToken) Client authorization based on JWT authorization grant.
        /// </summary>
        /// <remarks>
        /// Authorization of the ePrescription backend (E-Rezept-Fachdienst).
        /// <br/>
        /// <br/>**Client**&lt;/br&gt;
        /// <br/>The ePrescription backend shall send a signed JWT (bearerToken) according to requirement gemSpec_Aktensystem_ePAfuerAlle, A_25165*.
        /// <br/>The token shall contain a fresh parameter (see: _getFreshnessParameter_).
        /// <br/>
        /// <br/>**Provider**&lt;/br&gt;
        /// <br/>The received token shall be validated with HSM rule 'rr0'. The resulting HSM-ID-Token shall be added to the user session.
        /// <br/>The received token shall have a claim "sub", this claim shall state the telematik-id of the ePrescription backend. 
        /// <br/>
        /// <br/>The user session of the client shall be closed and all session related data shall be deleted in case operation is not successful.
        /// <br/>
        /// <br/>The VAU user preudonym as generated for the vau-channel (see: vau protocol) shall be returned in a successful operation response.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 200 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest | also for _bearerToken_ does not match token schema |
        /// <br/>| Invalid request | 403 | invalAuth | _bearerToken_ is invalid by means of HSM rule 'rr0' or timestamp |
        /// <br/>| Any other error | 500 | internalError ||
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| authorized user session with HSM-ID-Token for ePrescription backend exists | successful operation only |
        /// <br/>| user session and temporary data is deleted | failed operation only |
        /// </remarks>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK, Successful login</returns>
        /// <exception cref="AuthorizationServiceException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response2> SendAuthorizationRequestBearerTokenAsync(BearerTokenType body, string x_useragent);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// (sendAuthorizationRequestBearerToken) Client authorization based on JWT authorization grant.
        /// </summary>
        /// <remarks>
        /// Authorization of the ePrescription backend (E-Rezept-Fachdienst).
        /// <br/>
        /// <br/>**Client**&lt;/br&gt;
        /// <br/>The ePrescription backend shall send a signed JWT (bearerToken) according to requirement gemSpec_Aktensystem_ePAfuerAlle, A_25165*.
        /// <br/>The token shall contain a fresh parameter (see: _getFreshnessParameter_).
        /// <br/>
        /// <br/>**Provider**&lt;/br&gt;
        /// <br/>The received token shall be validated with HSM rule 'rr0'. The resulting HSM-ID-Token shall be added to the user session.
        /// <br/>The received token shall have a claim "sub", this claim shall state the telematik-id of the ePrescription backend. 
        /// <br/>
        /// <br/>The user session of the client shall be closed and all session related data shall be deleted in case operation is not successful.
        /// <br/>
        /// <br/>The VAU user preudonym as generated for the vau-channel (see: vau protocol) shall be returned in a successful operation response.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 200 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest | also for _bearerToken_ does not match token schema |
        /// <br/>| Invalid request | 403 | invalAuth | _bearerToken_ is invalid by means of HSM rule 'rr0' or timestamp |
        /// <br/>| Any other error | 500 | internalError ||
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| authorized user session with HSM-ID-Token for ePrescription backend exists | successful operation only |
        /// <br/>| user session and temporary data is deleted | failed operation only |
        /// </remarks>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK, Successful login</returns>
        /// <exception cref="AuthorizationServiceException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response2> SendAuthorizationRequestBearerTokenAsync(BearerTokenType body, string x_useragent, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// (sendAuthorizationRequestFdV) Send authorization request
        /// </summary>
        /// <remarks>
        /// Sends an authorization request to the authorization service.
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client shall use parameter _x-authorize_representative_ for the "Authorize Representative" use case,
        /// <br/> a login of a user on not owned device for representative entitlement only.
        /// <br/>The _x-authorize-representative_ parameter will force an authentication of the user with egK + pin only and limit the possible operations to entitlement management only.
        /// <br/>A client shall use the returned redirect url to invoke the authenticator. &lt;br/&gt;
        /// <br/>
        /// <br/>A client shall use parameter _x-authorize-egk_ for a login in guest mode with egk and pin, e.g. of a validation identity 
        /// <br/>(i.e. "Prüfkarte eGK"), forcing the authorization service to request an authentication at the identity provider 
        /// <br/>in guest mode (eGK + pin). 
        /// <br/>A client shall use the returned redirect url to invoke the authenticator.
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The authorization service shall send a pushed authorization request (PAR) to the IDP (see: find more details).
        /// <br/>
        /// <br/>The _redirect_uri_ parameter of the PAR shall be set to a predefined value when operation parameter 
        /// <br/>_x-redirecturi_ is not present, else the content of _x-redirecturi_ shall be used (according to A_25717-*).
        /// <br/>
        /// <br/>The authorize representative situation (_x-authorize-representative_ == _true_) shall be kept for the subsequent
        /// <br/>_sendAuthCodeFdV_ and device management operations. 
        /// <br/>
        /// <br/>For the _x-authorize-representative_ and the _x-authorize-egk_ case the PAR for the IDP shall include:
        /// <br/>- amr = urn:telematik:auth:guest:eGK
        /// <br/>
        /// <br/>_x-authorize-representative_ and _x-authorize-egk_ both should not be set to _true_ at the same time.
        /// <br/>
        /// <br/>This operation shall be rejected if the corresponding user session is already authorized. Repeated authorization
        /// <br/>attempts are not supported.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 302 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest | also if both "x-authorize"-parameters are set to _true_ |
        /// <br/>| Invalid request | 403 | invalAuth | includes any error of Authorization Service and IDP which is not mapped to 500 internal Server error |
        /// <br/>| unregistered redirecturi | 403 | invalRedir | redirecturi in _x-redirecturi_ is not known, registration required |
        /// <br/>| Invalid URI (x-idp-iss) | 404 | noResource | |
        /// <br/>| Repeated authorization attempt | 409 | statusMismatch | when user session is already authorized only |
        /// <br/>| Any other error | 500 | internalError ||
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| _authorize_representative_ kept for subsequent _sendAuthCodeFdV_ evaluation | if applicable |
        /// </remarks>
        /// <param name="x_idp_iss">The issuer Identifier (URL) of the IDP to be used for user authentication</param>
        /// <param name="x_authorize_representative">This parameter shall be absent or set to _true_ to indicate an authorization request without epa device management registration checks.</param>
        /// <param name="x_authorize_egk">This parameter shall be absent or set to _true_ to indicate an authorization request in guest mode with egk + pin e.g. for validation identities.</param>
        /// <param name="x_redirecturi">An optional redirecturi (URL) to be used in PAR for redirection of the authorizationcode. The redirecturi must be registered as valid on the epa application server (entity statement)</param>
        /// <param name="x_useragent">user agent information</param>
        /// <exception cref="AuthorizationServiceException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SendAuthorizationRequestFdVAsync(string x_idp_iss, bool? x_authorize_representative, bool? x_authorize_egk, string x_redirecturi, string x_useragent);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// (sendAuthorizationRequestFdV) Send authorization request
        /// </summary>
        /// <remarks>
        /// Sends an authorization request to the authorization service.
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client shall use parameter _x-authorize_representative_ for the "Authorize Representative" use case,
        /// <br/> a login of a user on not owned device for representative entitlement only.
        /// <br/>The _x-authorize-representative_ parameter will force an authentication of the user with egK + pin only and limit the possible operations to entitlement management only.
        /// <br/>A client shall use the returned redirect url to invoke the authenticator. &lt;br/&gt;
        /// <br/>
        /// <br/>A client shall use parameter _x-authorize-egk_ for a login in guest mode with egk and pin, e.g. of a validation identity 
        /// <br/>(i.e. "Prüfkarte eGK"), forcing the authorization service to request an authentication at the identity provider 
        /// <br/>in guest mode (eGK + pin). 
        /// <br/>A client shall use the returned redirect url to invoke the authenticator.
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The authorization service shall send a pushed authorization request (PAR) to the IDP (see: find more details).
        /// <br/>
        /// <br/>The _redirect_uri_ parameter of the PAR shall be set to a predefined value when operation parameter 
        /// <br/>_x-redirecturi_ is not present, else the content of _x-redirecturi_ shall be used (according to A_25717-*).
        /// <br/>
        /// <br/>The authorize representative situation (_x-authorize-representative_ == _true_) shall be kept for the subsequent
        /// <br/>_sendAuthCodeFdV_ and device management operations. 
        /// <br/>
        /// <br/>For the _x-authorize-representative_ and the _x-authorize-egk_ case the PAR for the IDP shall include:
        /// <br/>- amr = urn:telematik:auth:guest:eGK
        /// <br/>
        /// <br/>_x-authorize-representative_ and _x-authorize-egk_ both should not be set to _true_ at the same time.
        /// <br/>
        /// <br/>This operation shall be rejected if the corresponding user session is already authorized. Repeated authorization
        /// <br/>attempts are not supported.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 302 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest | also if both "x-authorize"-parameters are set to _true_ |
        /// <br/>| Invalid request | 403 | invalAuth | includes any error of Authorization Service and IDP which is not mapped to 500 internal Server error |
        /// <br/>| unregistered redirecturi | 403 | invalRedir | redirecturi in _x-redirecturi_ is not known, registration required |
        /// <br/>| Invalid URI (x-idp-iss) | 404 | noResource | |
        /// <br/>| Repeated authorization attempt | 409 | statusMismatch | when user session is already authorized only |
        /// <br/>| Any other error | 500 | internalError ||
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| _authorize_representative_ kept for subsequent _sendAuthCodeFdV_ evaluation | if applicable |
        /// </remarks>
        /// <param name="x_idp_iss">The issuer Identifier (URL) of the IDP to be used for user authentication</param>
        /// <param name="x_authorize_representative">This parameter shall be absent or set to _true_ to indicate an authorization request without epa device management registration checks.</param>
        /// <param name="x_authorize_egk">This parameter shall be absent or set to _true_ to indicate an authorization request in guest mode with egk + pin e.g. for validation identities.</param>
        /// <param name="x_redirecturi">An optional redirecturi (URL) to be used in PAR for redirection of the authorizationcode. The redirecturi must be registered as valid on the epa application server (entity statement)</param>
        /// <param name="x_useragent">user agent information</param>
        /// <exception cref="AuthorizationServiceException">A server side error occurred.</exception>
        System.Threading.Tasks.Task SendAuthorizationRequestFdVAsync(string x_idp_iss, bool? x_authorize_representative, bool? x_authorize_egk, string x_redirecturi, string x_useragent, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// (sendAuthCodeFdV) Send authorization code
        /// </summary>
        /// <remarks>
        /// Send the authorization code to the authorization service to complete the login and (optional)
        /// <br/>verify the device registration.
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client shall always send the authorization code received from the authenticator / IDP. &lt;br/&gt;
        /// <br/>
        /// <br/>A client shall send both, _x-device-identifier_ and _x-device-token_, on login to the home system
        /// <br/>of the user for proof of a registered device.
        /// <br/>
        /// <br/>If the user has a device registration in another home system, then a device attestation from his home 
        /// <br/>system must be used and a client shall submit _x-device-attestation_ (instead of _x-device-identifier_ 
        /// <br/>and _x-device-token_). A client can obtain a device attestation from the home system via a 
        /// <br/>_getDeviceAttestation_ operation call.  
        /// <br/>
        /// <br/>A client shall not send _x-device-identifier_ and _x-device-token_ or even _x-device-attestation_ 
        /// <br/>(suppress parameters at all) if the device is not yet registered and confirmed or if the preceding 
        /// <br/>_sendAuthorizationRequestFdV_ call includes the parameter _x-authorize_representative_ == _true_.
        /// <br/>
        /// <br/>(For registration of a new device, including confirmation of the registration, see Device Management 
        /// <br/>Service operations _registerDevice_ and _confirmDevice_). 
        /// <br/>
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The provided authorization code shall be exchanged for an ID-Token with the IDP. The ID-Token shall be converted
        /// <br/>into a HSM-ID-Token with an extended validity period.
        /// <br/>
        /// <br/>Device verification - home system:&lt;/br&gt;
        /// <br/>If _x-device-identifier_ and _x-device-token_ are both submitted the device verification starts immediately after
        /// <br/>the authorization completion.
        /// <br/>Device identifier and -token shall be verified with the registered values.
        /// <br/>The x-device-identifier / x-device-token check shall only consider device registrations for the authorized user.
        /// <br/>
        /// <br/>Device verification - other than home system:&lt;/br&gt;
        /// <br/>If _x-device-attestation_ is submitted the device verification starts immediately after the authorization completion.
        /// <br/>The authorization service shall accept a device attestation in case
        /// <br/>  - signature is valid
        /// <br/>  - "exp" expiration_time is a timestamp 120 minutes in the future "iat".
        /// <br/>  - current time is greater or equal than 'iat' and less than 'exp' with 15 seconds tolerance ('iat' - 15s &lt;= current time &lt; 'exp' + 15s).          
        /// <br/>  - claim _actorId_ from device attestation matches kvnr of ID-Token or HSM-ID-Token.
        /// <br/>
        /// <br/>If the device attestation is valid by signature and time, and the KVNR submitted in device attestation matches the 
        /// <br/>KVNR of the authorized user the authorization service shall accept the device registration.
        /// <br/>
        /// <br/>On success (ID-Token / HSM-ID-Token received and device binding check successful) a new user session shall be instantiated, 
        /// <br/>associated to the HSM-ID-Token.
        /// <br/>
        /// <br/>If device verification succeeds, access to all services of a health record shall be possible for the associated
        /// <br/>user session.
        /// <br/>if x-authorize-representative is set, access to the user's health record entitlement management only shall be
        /// <br/>possible for the user session.
        /// <br/>In all other (success cases) access of the user session shall be limited to the device management service.
        /// <br/>
        /// <br/>The user session of a client shall be closed and all session related data shall be deleted in case operation is not successful.
        /// <br/>
        /// <br/>The VAU user preudonym as generated for the vau-channel (see: vau protocol) shall be returned in a successful operation response.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 200 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Only _x-device-identifier_ or _x-device-token_ provided | 400 | paramExcpected | both parameters required or none |
        /// <br/>| (_x-device-identifier_ and/or _x-device-token_) and _x-device-attestation_ provided | 400 | paramExcpected | use only registration of home system, another system or none (yet unregistered device) |
        /// <br/>| _authorize_representative_ is set and _x-device-identifier_ and/or _x-device-token_ and/or x-device-attestation_ provided | 400 | authorizeRep | _x-authorize_representative_ from preceding sendAuthorizationRequestFdV |
        /// <br/>| Requestor role is not _oid_versicherter_ | 403 | invalidOid ||
        /// <br/>| _authorizationCode_ not valid | 403 | invalAuth | includes any error of Authorization Service and IDP which is not mapped to 500 internal Server error |
        /// <br/>| Wrong _x-device-token_  | 403 | invalidToken | if both parameters avaiable and allowed|
        /// <br/>| Invalid _x-device-attestation_ | 403 | invalSignature ||
        /// <br/>| Device registration does not exist (_x-device-identifier_)| 404| noResource | also if device is not associated to requestor kvnr |
        /// <br/>| Device registration not confirmed (_status_ == _pending_) | 409 | statusMismatch | confirm pending device registration before retry |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| user session has valid HSM-ID-Token | successful operation only |
        /// <br/>| user session contains device verification result | successful operation with device parameters only |
        /// <br/>| _lastUse_ of device registration is updated to current time | successful operation with device parameters only |
        /// <br/>| user session and temporary data is deleted | failed operation only |
        /// </remarks>
        /// <param name="x_device_identifier">The deviceidentifier of a device registration</param>
        /// <param name="x_device_token">The devicetoken of a device registration</param>
        /// <param name="x_device_attestation">The deviceAttestation of a device registration</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK, Successful login</returns>
        /// <exception cref="AuthorizationServiceException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response4> SendAuthCodeFdVAsync(System.Guid? x_device_identifier, string x_device_token, DeviceAttestationType x_device_attestation, SendAuthCodeFdVtype body, string x_useragent);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// (sendAuthCodeFdV) Send authorization code
        /// </summary>
        /// <remarks>
        /// Send the authorization code to the authorization service to complete the login and (optional)
        /// <br/>verify the device registration.
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client shall always send the authorization code received from the authenticator / IDP. &lt;br/&gt;
        /// <br/>
        /// <br/>A client shall send both, _x-device-identifier_ and _x-device-token_, on login to the home system
        /// <br/>of the user for proof of a registered device.
        /// <br/>
        /// <br/>If the user has a device registration in another home system, then a device attestation from his home 
        /// <br/>system must be used and a client shall submit _x-device-attestation_ (instead of _x-device-identifier_ 
        /// <br/>and _x-device-token_). A client can obtain a device attestation from the home system via a 
        /// <br/>_getDeviceAttestation_ operation call.  
        /// <br/>
        /// <br/>A client shall not send _x-device-identifier_ and _x-device-token_ or even _x-device-attestation_ 
        /// <br/>(suppress parameters at all) if the device is not yet registered and confirmed or if the preceding 
        /// <br/>_sendAuthorizationRequestFdV_ call includes the parameter _x-authorize_representative_ == _true_.
        /// <br/>
        /// <br/>(For registration of a new device, including confirmation of the registration, see Device Management 
        /// <br/>Service operations _registerDevice_ and _confirmDevice_). 
        /// <br/>
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The provided authorization code shall be exchanged for an ID-Token with the IDP. The ID-Token shall be converted
        /// <br/>into a HSM-ID-Token with an extended validity period.
        /// <br/>
        /// <br/>Device verification - home system:&lt;/br&gt;
        /// <br/>If _x-device-identifier_ and _x-device-token_ are both submitted the device verification starts immediately after
        /// <br/>the authorization completion.
        /// <br/>Device identifier and -token shall be verified with the registered values.
        /// <br/>The x-device-identifier / x-device-token check shall only consider device registrations for the authorized user.
        /// <br/>
        /// <br/>Device verification - other than home system:&lt;/br&gt;
        /// <br/>If _x-device-attestation_ is submitted the device verification starts immediately after the authorization completion.
        /// <br/>The authorization service shall accept a device attestation in case
        /// <br/>  - signature is valid
        /// <br/>  - "exp" expiration_time is a timestamp 120 minutes in the future "iat".
        /// <br/>  - current time is greater or equal than 'iat' and less than 'exp' with 15 seconds tolerance ('iat' - 15s &lt;= current time &lt; 'exp' + 15s).          
        /// <br/>  - claim _actorId_ from device attestation matches kvnr of ID-Token or HSM-ID-Token.
        /// <br/>
        /// <br/>If the device attestation is valid by signature and time, and the KVNR submitted in device attestation matches the 
        /// <br/>KVNR of the authorized user the authorization service shall accept the device registration.
        /// <br/>
        /// <br/>On success (ID-Token / HSM-ID-Token received and device binding check successful) a new user session shall be instantiated, 
        /// <br/>associated to the HSM-ID-Token.
        /// <br/>
        /// <br/>If device verification succeeds, access to all services of a health record shall be possible for the associated
        /// <br/>user session.
        /// <br/>if x-authorize-representative is set, access to the user's health record entitlement management only shall be
        /// <br/>possible for the user session.
        /// <br/>In all other (success cases) access of the user session shall be limited to the device management service.
        /// <br/>
        /// <br/>The user session of a client shall be closed and all session related data shall be deleted in case operation is not successful.
        /// <br/>
        /// <br/>The VAU user preudonym as generated for the vau-channel (see: vau protocol) shall be returned in a successful operation response.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 200 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Only _x-device-identifier_ or _x-device-token_ provided | 400 | paramExcpected | both parameters required or none |
        /// <br/>| (_x-device-identifier_ and/or _x-device-token_) and _x-device-attestation_ provided | 400 | paramExcpected | use only registration of home system, another system or none (yet unregistered device) |
        /// <br/>| _authorize_representative_ is set and _x-device-identifier_ and/or _x-device-token_ and/or x-device-attestation_ provided | 400 | authorizeRep | _x-authorize_representative_ from preceding sendAuthorizationRequestFdV |
        /// <br/>| Requestor role is not _oid_versicherter_ | 403 | invalidOid ||
        /// <br/>| _authorizationCode_ not valid | 403 | invalAuth | includes any error of Authorization Service and IDP which is not mapped to 500 internal Server error |
        /// <br/>| Wrong _x-device-token_  | 403 | invalidToken | if both parameters avaiable and allowed|
        /// <br/>| Invalid _x-device-attestation_ | 403 | invalSignature ||
        /// <br/>| Device registration does not exist (_x-device-identifier_)| 404| noResource | also if device is not associated to requestor kvnr |
        /// <br/>| Device registration not confirmed (_status_ == _pending_) | 409 | statusMismatch | confirm pending device registration before retry |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| user session has valid HSM-ID-Token | successful operation only |
        /// <br/>| user session contains device verification result | successful operation with device parameters only |
        /// <br/>| _lastUse_ of device registration is updated to current time | successful operation with device parameters only |
        /// <br/>| user session and temporary data is deleted | failed operation only |
        /// </remarks>
        /// <param name="x_device_identifier">The deviceidentifier of a device registration</param>
        /// <param name="x_device_token">The devicetoken of a device registration</param>
        /// <param name="x_device_attestation">The deviceAttestation of a device registration</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK, Successful login</returns>
        /// <exception cref="AuthorizationServiceException">A server side error occurred.</exception>
        System.Threading.Tasks.Task<Response4> SendAuthCodeFdVAsync(System.Guid? x_device_identifier, string x_device_token, DeviceAttestationType x_device_attestation, SendAuthCodeFdVtype body, string x_useragent, System.Threading.CancellationToken cancellationToken);

        /// <summary>
        /// (logoutFdV) Logout from user session.
        /// </summary>
        /// <remarks>
        /// A logout terminates the associated user session. For any further service usage a new 
        /// <br/>authentication of the user is required. 
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client shall perform this explicit logout to close the user session and all 
        /// <br/>health record related activities. For further access a client shall perform a new login, including
        /// <br/>negotiation of a new VAU-channel.
        /// <br/>
        /// <br/> **Provider**:&lt;/br&gt;
        /// <br/> The user session of a client shall be closed and all session related 
        /// <br/> data shall be deleted. Associated health record contexts shall be released / closed.
        /// <br/>
        /// <br/> | Conditions | Status code | Error code | Remarks |
        /// <br/> |------------|-------------|------------|---------|
        /// <br/> | Successful logout | 204 |||
        /// <br/> | Request does not match schema | 400 | malformedRequest ||
        /// <br/> | Any other error | 500 | internalError ||
        /// <br/>
        /// <br/>  &lt;/br&gt;
        /// <br/> | Postconditions                        | Remarks |
        /// <br/> |---------------------------------------|---------|
        /// <br/> | The user session and all related temporary data is terminated / deleted | successful operation only |
        /// </remarks>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK</returns>
        /// <exception cref="AuthorizationServiceException">A server side error occurred.</exception>
        System.Threading.Tasks.Task LogoutFdVAsync(string x_useragent);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// (logoutFdV) Logout from user session.
        /// </summary>
        /// <remarks>
        /// A logout terminates the associated user session. For any further service usage a new 
        /// <br/>authentication of the user is required. 
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client shall perform this explicit logout to close the user session and all 
        /// <br/>health record related activities. For further access a client shall perform a new login, including
        /// <br/>negotiation of a new VAU-channel.
        /// <br/>
        /// <br/> **Provider**:&lt;/br&gt;
        /// <br/> The user session of a client shall be closed and all session related 
        /// <br/> data shall be deleted. Associated health record contexts shall be released / closed.
        /// <br/>
        /// <br/> | Conditions | Status code | Error code | Remarks |
        /// <br/> |------------|-------------|------------|---------|
        /// <br/> | Successful logout | 204 |||
        /// <br/> | Request does not match schema | 400 | malformedRequest ||
        /// <br/> | Any other error | 500 | internalError ||
        /// <br/>
        /// <br/>  &lt;/br&gt;
        /// <br/> | Postconditions                        | Remarks |
        /// <br/> |---------------------------------------|---------|
        /// <br/> | The user session and all related temporary data is terminated / deleted | successful operation only |
        /// </remarks>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK</returns>
        /// <exception cref="AuthorizationServiceException">A server side error occurred.</exception>
        System.Threading.Tasks.Task LogoutFdVAsync(string x_useragent, System.Threading.CancellationToken cancellationToken);

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AuthorizationServiceClient : IAuthorizationServiceClient
    {
        private System.Net.Http.HttpClient _httpClient;
        private static System.Lazy<System.Text.Json.JsonSerializerOptions> _settings = new System.Lazy<System.Text.Json.JsonSerializerOptions>(CreateSerializerSettings, true);
        private System.Text.Json.JsonSerializerOptions _instanceSettings;

    #pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        public AuthorizationServiceClient(System.Net.Http.HttpClient httpClient)
    #pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        {
            _httpClient = httpClient;
            Initialize();
        }

        private static System.Text.Json.JsonSerializerOptions CreateSerializerSettings()
        {
            var settings = new System.Text.Json.JsonSerializerOptions();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        protected System.Text.Json.JsonSerializerOptions JsonSerializerSettings { get { return _instanceSettings ?? _settings.Value; } }

        static partial void UpdateJsonSerializerSettings(System.Text.Json.JsonSerializerOptions settings);

        partial void Initialize();

        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>
        /// (getFHIRVZDtoken) Get the FHIR VZD search access-token
        /// </summary>
        /// <remarks>
        /// Get the directory service (FHIR VZD) search-token of the health record system.
        /// <br/>This operation is limited to authenticated users (IDP) only.
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client shall use the provided search access-token for directory service queries instead of an own, individual
        /// <br/>registration.
        /// <br/>
        /// <br/>**Provider**:
        /// <br/>The authorization service shall return the search access-token as received from the FHIR Directory.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 200 |||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| none ||
        /// </remarks>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK</returns>
        /// <exception cref="AuthorizationServiceException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<SearchAccessTokenType> GetFHIRVZDtokenAsync(string x_useragent)
        {
            return GetFHIRVZDtokenAsync(x_useragent, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// (getFHIRVZDtoken) Get the FHIR VZD search access-token
        /// </summary>
        /// <remarks>
        /// Get the directory service (FHIR VZD) search-token of the health record system.
        /// <br/>This operation is limited to authenticated users (IDP) only.
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client shall use the provided search access-token for directory service queries instead of an own, individual
        /// <br/>registration.
        /// <br/>
        /// <br/>**Provider**:
        /// <br/>The authorization service shall return the search access-token as received from the FHIR Directory.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 200 |||
        /// <br/>| Requestor not authorized | 403 | invalAuth | no user session with valid ID-Token available |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| none ||
        /// </remarks>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK</returns>
        /// <exception cref="AuthorizationServiceException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<SearchAccessTokenType> GetFHIRVZDtokenAsync(string x_useragent, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (x_useragent == null)
                        throw new System.ArgumentNullException("x_useragent");
                    request_.Headers.TryAddWithoutValidation("x-useragent", ConvertToString(x_useragent, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "epa/vzd/v1/vzdToken"
                    urlBuilder_.Append("epa/vzd/v1/vzdToken");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<SearchAccessTokenType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AuthorizationServiceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AuthorizationServiceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AuthorizationServiceException<ErrorType>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new AuthorizationServiceException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// (getNonce) Generate nonce (random value) for an authorization request
        /// </summary>
        /// <remarks>
        /// A nonce is a generated unique random value. This operation provides the nonce
        /// <br/>for the client (attestation).&lt;/br&gt; 
        /// <br/>Remark: This is NOT the nonce used by the authorization
        /// <br/>service towards the IDP in an IDP flow! 
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client shall sign the received nonce. The signed nonce shall be used as client 
        /// <br/>attestation for the authorization requests finalization (_sendAuthCodeSC_).
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The nonce shall be stored for later comparison in a subsequent _sendAuthCodeSc_ operation.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 200 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| The nonce is kept for subsequent _sendAuthCodeSC_ operation ||
        /// </remarks>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>Ok.</returns>
        /// <exception cref="AuthorizationServiceException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response> GetNonceAsync(string x_useragent)
        {
            return GetNonceAsync(x_useragent, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// (getNonce) Generate nonce (random value) for an authorization request
        /// </summary>
        /// <remarks>
        /// A nonce is a generated unique random value. This operation provides the nonce
        /// <br/>for the client (attestation).&lt;/br&gt; 
        /// <br/>Remark: This is NOT the nonce used by the authorization
        /// <br/>service towards the IDP in an IDP flow! 
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client shall sign the received nonce. The signed nonce shall be used as client 
        /// <br/>attestation for the authorization requests finalization (_sendAuthCodeSC_).
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The nonce shall be stored for later comparison in a subsequent _sendAuthCodeSc_ operation.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 200 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| The nonce is kept for subsequent _sendAuthCodeSC_ operation ||
        /// </remarks>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>Ok.</returns>
        /// <exception cref="AuthorizationServiceException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response> GetNonceAsync(string x_useragent, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (x_useragent == null)
                        throw new System.ArgumentNullException("x_useragent");
                    request_.Headers.TryAddWithoutValidation("x-useragent", ConvertToString(x_useragent, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "epa/authz/v1/getNonce"
                    urlBuilder_.Append("epa/authz/v1/getNonce");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AuthorizationServiceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AuthorizationServiceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AuthorizationServiceException<ErrorType>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AuthorizationServiceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AuthorizationServiceException<ErrorType>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new AuthorizationServiceException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// (sendAuthorizationRequestSC) Send authorization request
        /// </summary>
        /// <remarks>
        /// Request authorization for a smartcard (SMC-B) based client.
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client will receive a well prepared redirection uri and parameters for the authoriation request
        /// <br/>towards the authenticator. A client shall invoke the authenticator and IDP flow to revceive an 
        /// <br/>authorization code for the subsequent _sendAuthCodeSC_ operation.
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The authorization server shall prepare a complete redirection uri and authorization request parameters 
        /// <br/>(PAR-URI) for the central smartcard IDP. 
        /// <br/>This operation shall be rejected if the corresponding user session is already authorized. Repeated authorization
        /// <br/>attempts are not supported.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 302 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Invalid request | 403 | invalAuth | includes any error of Authorization Service which is not mapped to 500 internal Server error |
        /// <br/>| Repeated authorization attempt | 409 | statusMismatch | when user session is already authorized only |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| none ||
        /// </remarks>
        /// <param name="x_useragent">user agent information</param>
        /// <exception cref="AuthorizationServiceException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SendAuthorizationRequestSCAsync(string x_useragent)
        {
            return SendAuthorizationRequestSCAsync(x_useragent, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// (sendAuthorizationRequestSC) Send authorization request
        /// </summary>
        /// <remarks>
        /// Request authorization for a smartcard (SMC-B) based client.
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client will receive a well prepared redirection uri and parameters for the authoriation request
        /// <br/>towards the authenticator. A client shall invoke the authenticator and IDP flow to revceive an 
        /// <br/>authorization code for the subsequent _sendAuthCodeSC_ operation.
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The authorization server shall prepare a complete redirection uri and authorization request parameters 
        /// <br/>(PAR-URI) for the central smartcard IDP. 
        /// <br/>This operation shall be rejected if the corresponding user session is already authorized. Repeated authorization
        /// <br/>attempts are not supported.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 302 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Invalid request | 403 | invalAuth | includes any error of Authorization Service which is not mapped to 500 internal Server error |
        /// <br/>| Repeated authorization attempt | 409 | statusMismatch | when user session is already authorized only |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| none ||
        /// </remarks>
        /// <param name="x_useragent">user agent information</param>
        /// <exception cref="AuthorizationServiceException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SendAuthorizationRequestSCAsync(string x_useragent, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (x_useragent == null)
                        throw new System.ArgumentNullException("x_useragent");
                    request_.Headers.TryAddWithoutValidation("x-useragent", ConvertToString(x_useragent, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "epa/authz/v1/send_authorization_request_sc"
                    urlBuilder_.Append("epa/authz/v1/send_authorization_request_sc");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 302)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new AuthorizationServiceException("Found", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AuthorizationServiceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AuthorizationServiceException<ErrorType>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AuthorizationServiceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AuthorizationServiceException<ErrorType>("Forbidden.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AuthorizationServiceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AuthorizationServiceException<ErrorType>("Conflict.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AuthorizationServiceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AuthorizationServiceException<ErrorType>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new AuthorizationServiceException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// (sendAuthCodeSC) Send authorization code
        /// </summary>
        /// <remarks>
        /// After successful user authentication the authorization code grant was returned to the authorization 
        /// <br/>service, that is exchanged for an ID token at the IDP's token endpoint using this operation.
        /// <br/>This operation is limited to users of the "Allowed usergroups for Authorization SMC-B"
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client shall submit the authorization code received from the authenticator and the client attestation
        /// <br/>(signed nonce)
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The authorization service shall use the authorization code to prepare a token request for the IDP and receive
        /// <br/>the encrypted ID-Token in return. 
        /// <br/>The received ID-Token shall be validated with HSM rule 'rr0'. The resulting HSM-ID-Token shall be added to the user session.
        /// <br/>
        /// <br/>The authorization service shall further validate the ID-token against the stored nonce (from a preceding _getNonce_ operation)
        /// <br/>and the client attestation:
        /// <br/>- _clientAttest_ is valid if
        /// <br/>  - signature is valid
        /// <br/>  - "exp" expiration_time is a timestamp 20 minutes in the future "iat".
        /// <br/>  - user has role as in "Allowed usergroups for Authorization SMC-B" (from signature cert)
        /// <br/>- stored nonce shall not be outdated
        /// <br/>- stored nonce shall match client attestation nonce
        /// <br/>- Telematik-Id of client attestation (from signature cert) shall match the telematik-id claim of the ID-Token 
        /// <br/>
        /// <br/>The user session of the client shall be closed and all session related data shall be deleted in case operation is not successful.
        /// <br/>
        /// <br/>The nonce shall be discarded, i.e. reuse of a client attestation for user session establishment shall be rejected. 
        /// <br/>
        /// <br/>The VAU user preudonym as generated for the vau-channel (see: vau protocol) shall be returned in a successful operation response.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 200 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Invalid request | 403 | invalAuth | includes any error of Authorization Service which are not mapped to 500 internal Server error |
        /// <br/>| No or outdated nonce | 409 | statusMismatch | No preceding _getNonce_ call or stored nonce outdated/invalid |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| The nonce is discarded ||
        /// <br/>| User session has valid HSM-ID-Token for requesting client (telematik-id) | successful operation only |
        /// <br/>| User session and temporary data is deleted | failed operation only |
        /// </remarks>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK, Successful login</returns>
        /// <exception cref="AuthorizationServiceException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response2> SendAuthCodeSCAsync(SendAuthCodeSCtype body, string x_useragent)
        {
            return SendAuthCodeSCAsync(body, x_useragent, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// (sendAuthCodeSC) Send authorization code
        /// </summary>
        /// <remarks>
        /// After successful user authentication the authorization code grant was returned to the authorization 
        /// <br/>service, that is exchanged for an ID token at the IDP's token endpoint using this operation.
        /// <br/>This operation is limited to users of the "Allowed usergroups for Authorization SMC-B"
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client shall submit the authorization code received from the authenticator and the client attestation
        /// <br/>(signed nonce)
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The authorization service shall use the authorization code to prepare a token request for the IDP and receive
        /// <br/>the encrypted ID-Token in return. 
        /// <br/>The received ID-Token shall be validated with HSM rule 'rr0'. The resulting HSM-ID-Token shall be added to the user session.
        /// <br/>
        /// <br/>The authorization service shall further validate the ID-token against the stored nonce (from a preceding _getNonce_ operation)
        /// <br/>and the client attestation:
        /// <br/>- _clientAttest_ is valid if
        /// <br/>  - signature is valid
        /// <br/>  - "exp" expiration_time is a timestamp 20 minutes in the future "iat".
        /// <br/>  - user has role as in "Allowed usergroups for Authorization SMC-B" (from signature cert)
        /// <br/>- stored nonce shall not be outdated
        /// <br/>- stored nonce shall match client attestation nonce
        /// <br/>- Telematik-Id of client attestation (from signature cert) shall match the telematik-id claim of the ID-Token 
        /// <br/>
        /// <br/>The user session of the client shall be closed and all session related data shall be deleted in case operation is not successful.
        /// <br/>
        /// <br/>The nonce shall be discarded, i.e. reuse of a client attestation for user session establishment shall be rejected. 
        /// <br/>
        /// <br/>The VAU user preudonym as generated for the vau-channel (see: vau protocol) shall be returned in a successful operation response.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 200 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Invalid request | 403 | invalAuth | includes any error of Authorization Service which are not mapped to 500 internal Server error |
        /// <br/>| No or outdated nonce | 409 | statusMismatch | No preceding _getNonce_ call or stored nonce outdated/invalid |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| The nonce is discarded ||
        /// <br/>| User session has valid HSM-ID-Token for requesting client (telematik-id) | successful operation only |
        /// <br/>| User session and temporary data is deleted | failed operation only |
        /// </remarks>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK, Successful login</returns>
        /// <exception cref="AuthorizationServiceException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response2> SendAuthCodeSCAsync(SendAuthCodeSCtype body, string x_useragent, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (x_useragent == null)
                        throw new System.ArgumentNullException("x_useragent");
                    request_.Headers.TryAddWithoutValidation("x-useragent", ConvertToString(x_useragent, System.Globalization.CultureInfo.InvariantCulture));
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "epa/authz/v1/send_authcode_sc"
                    urlBuilder_.Append("epa/authz/v1/send_authcode_sc");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response2>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AuthorizationServiceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AuthorizationServiceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AuthorizationServiceException<ErrorType>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AuthorizationServiceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AuthorizationServiceException<ErrorType>("Forbidden.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AuthorizationServiceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AuthorizationServiceException<ErrorType>("Conflict.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AuthorizationServiceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AuthorizationServiceException<ErrorType>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new AuthorizationServiceException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// (getFreshnessParameter) Get freshness parameter for a bearer token
        /// </summary>
        /// <remarks>
        /// Get a new freshness parameter for a new bearer token for the authorization by bearer token.
        /// <br/>
        /// <br/>**Client**&lt;/br&gt;
        /// <br/>The ePrescription backend shall use the freshness parameter for a signed JWT (bearer token) according to requirement gemSpec_Aktensystem_ePAfuerAlle, A_25165*.
        /// <br/>
        /// <br/>**Provider**&lt;/br&gt;
        /// <br/>The returned freshness parameter shall follow the requirements in gemSpec_Krypt, A_24658* and be verifiable by HSM rule 'rr0'. 
        /// <br/>
        /// <br/> | Conditions | Status code | Error code | Remarks |
        /// <br/> |------------|-------------|------------|---------|
        /// <br/> | Successful operation | 200 |||
        /// <br/> | Any other error | 500 | internalError ||
        /// <br/>
        /// <br/>  &lt;/br&gt;
        /// <br/> | Postconditions                        | Remarks |
        /// <br/> |---------------------------------------|---------|
        /// <br/> | none ||
        /// </remarks>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK</returns>
        /// <exception cref="AuthorizationServiceException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response3> GetFreshnessParameterAsync(string x_useragent)
        {
            return GetFreshnessParameterAsync(x_useragent, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// (getFreshnessParameter) Get freshness parameter for a bearer token
        /// </summary>
        /// <remarks>
        /// Get a new freshness parameter for a new bearer token for the authorization by bearer token.
        /// <br/>
        /// <br/>**Client**&lt;/br&gt;
        /// <br/>The ePrescription backend shall use the freshness parameter for a signed JWT (bearer token) according to requirement gemSpec_Aktensystem_ePAfuerAlle, A_25165*.
        /// <br/>
        /// <br/>**Provider**&lt;/br&gt;
        /// <br/>The returned freshness parameter shall follow the requirements in gemSpec_Krypt, A_24658* and be verifiable by HSM rule 'rr0'. 
        /// <br/>
        /// <br/> | Conditions | Status code | Error code | Remarks |
        /// <br/> |------------|-------------|------------|---------|
        /// <br/> | Successful operation | 200 |||
        /// <br/> | Any other error | 500 | internalError ||
        /// <br/>
        /// <br/>  &lt;/br&gt;
        /// <br/> | Postconditions                        | Remarks |
        /// <br/> |---------------------------------------|---------|
        /// <br/> | none ||
        /// </remarks>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK</returns>
        /// <exception cref="AuthorizationServiceException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response3> GetFreshnessParameterAsync(string x_useragent, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (x_useragent == null)
                        throw new System.ArgumentNullException("x_useragent");
                    request_.Headers.TryAddWithoutValidation("x-useragent", ConvertToString(x_useragent, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "epa/authz/v1/freshness"
                    urlBuilder_.Append("epa/authz/v1/freshness");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response3>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AuthorizationServiceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AuthorizationServiceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AuthorizationServiceException<ErrorType>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new AuthorizationServiceException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// (sendAuthorizationRequestBearerToken) Client authorization based on JWT authorization grant.
        /// </summary>
        /// <remarks>
        /// Authorization of the ePrescription backend (E-Rezept-Fachdienst).
        /// <br/>
        /// <br/>**Client**&lt;/br&gt;
        /// <br/>The ePrescription backend shall send a signed JWT (bearerToken) according to requirement gemSpec_Aktensystem_ePAfuerAlle, A_25165*.
        /// <br/>The token shall contain a fresh parameter (see: _getFreshnessParameter_).
        /// <br/>
        /// <br/>**Provider**&lt;/br&gt;
        /// <br/>The received token shall be validated with HSM rule 'rr0'. The resulting HSM-ID-Token shall be added to the user session.
        /// <br/>The received token shall have a claim "sub", this claim shall state the telematik-id of the ePrescription backend. 
        /// <br/>
        /// <br/>The user session of the client shall be closed and all session related data shall be deleted in case operation is not successful.
        /// <br/>
        /// <br/>The VAU user preudonym as generated for the vau-channel (see: vau protocol) shall be returned in a successful operation response.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 200 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest | also for _bearerToken_ does not match token schema |
        /// <br/>| Invalid request | 403 | invalAuth | _bearerToken_ is invalid by means of HSM rule 'rr0' or timestamp |
        /// <br/>| Any other error | 500 | internalError ||
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| authorized user session with HSM-ID-Token for ePrescription backend exists | successful operation only |
        /// <br/>| user session and temporary data is deleted | failed operation only |
        /// </remarks>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK, Successful login</returns>
        /// <exception cref="AuthorizationServiceException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response2> SendAuthorizationRequestBearerTokenAsync(BearerTokenType body, string x_useragent)
        {
            return SendAuthorizationRequestBearerTokenAsync(body, x_useragent, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// (sendAuthorizationRequestBearerToken) Client authorization based on JWT authorization grant.
        /// </summary>
        /// <remarks>
        /// Authorization of the ePrescription backend (E-Rezept-Fachdienst).
        /// <br/>
        /// <br/>**Client**&lt;/br&gt;
        /// <br/>The ePrescription backend shall send a signed JWT (bearerToken) according to requirement gemSpec_Aktensystem_ePAfuerAlle, A_25165*.
        /// <br/>The token shall contain a fresh parameter (see: _getFreshnessParameter_).
        /// <br/>
        /// <br/>**Provider**&lt;/br&gt;
        /// <br/>The received token shall be validated with HSM rule 'rr0'. The resulting HSM-ID-Token shall be added to the user session.
        /// <br/>The received token shall have a claim "sub", this claim shall state the telematik-id of the ePrescription backend. 
        /// <br/>
        /// <br/>The user session of the client shall be closed and all session related data shall be deleted in case operation is not successful.
        /// <br/>
        /// <br/>The VAU user preudonym as generated for the vau-channel (see: vau protocol) shall be returned in a successful operation response.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 200 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest | also for _bearerToken_ does not match token schema |
        /// <br/>| Invalid request | 403 | invalAuth | _bearerToken_ is invalid by means of HSM rule 'rr0' or timestamp |
        /// <br/>| Any other error | 500 | internalError ||
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| authorized user session with HSM-ID-Token for ePrescription backend exists | successful operation only |
        /// <br/>| user session and temporary data is deleted | failed operation only |
        /// </remarks>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK, Successful login</returns>
        /// <exception cref="AuthorizationServiceException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response2> SendAuthorizationRequestBearerTokenAsync(BearerTokenType body, string x_useragent, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (x_useragent == null)
                        throw new System.ArgumentNullException("x_useragent");
                    request_.Headers.TryAddWithoutValidation("x-useragent", ConvertToString(x_useragent, System.Globalization.CultureInfo.InvariantCulture));
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "epa/authz/v1/send_authorization_request_bearertoken"
                    urlBuilder_.Append("epa/authz/v1/send_authorization_request_bearertoken");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response2>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AuthorizationServiceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AuthorizationServiceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AuthorizationServiceException<ErrorType>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AuthorizationServiceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AuthorizationServiceException<ErrorType>("Forbidden.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AuthorizationServiceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AuthorizationServiceException<ErrorType>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new AuthorizationServiceException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// (sendAuthorizationRequestFdV) Send authorization request
        /// </summary>
        /// <remarks>
        /// Sends an authorization request to the authorization service.
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client shall use parameter _x-authorize_representative_ for the "Authorize Representative" use case,
        /// <br/> a login of a user on not owned device for representative entitlement only.
        /// <br/>The _x-authorize-representative_ parameter will force an authentication of the user with egK + pin only and limit the possible operations to entitlement management only.
        /// <br/>A client shall use the returned redirect url to invoke the authenticator. &lt;br/&gt;
        /// <br/>
        /// <br/>A client shall use parameter _x-authorize-egk_ for a login in guest mode with egk and pin, e.g. of a validation identity 
        /// <br/>(i.e. "Prüfkarte eGK"), forcing the authorization service to request an authentication at the identity provider 
        /// <br/>in guest mode (eGK + pin). 
        /// <br/>A client shall use the returned redirect url to invoke the authenticator.
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The authorization service shall send a pushed authorization request (PAR) to the IDP (see: find more details).
        /// <br/>
        /// <br/>The _redirect_uri_ parameter of the PAR shall be set to a predefined value when operation parameter 
        /// <br/>_x-redirecturi_ is not present, else the content of _x-redirecturi_ shall be used (according to A_25717-*).
        /// <br/>
        /// <br/>The authorize representative situation (_x-authorize-representative_ == _true_) shall be kept for the subsequent
        /// <br/>_sendAuthCodeFdV_ and device management operations. 
        /// <br/>
        /// <br/>For the _x-authorize-representative_ and the _x-authorize-egk_ case the PAR for the IDP shall include:
        /// <br/>- amr = urn:telematik:auth:guest:eGK
        /// <br/>
        /// <br/>_x-authorize-representative_ and _x-authorize-egk_ both should not be set to _true_ at the same time.
        /// <br/>
        /// <br/>This operation shall be rejected if the corresponding user session is already authorized. Repeated authorization
        /// <br/>attempts are not supported.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 302 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest | also if both "x-authorize"-parameters are set to _true_ |
        /// <br/>| Invalid request | 403 | invalAuth | includes any error of Authorization Service and IDP which is not mapped to 500 internal Server error |
        /// <br/>| unregistered redirecturi | 403 | invalRedir | redirecturi in _x-redirecturi_ is not known, registration required |
        /// <br/>| Invalid URI (x-idp-iss) | 404 | noResource | |
        /// <br/>| Repeated authorization attempt | 409 | statusMismatch | when user session is already authorized only |
        /// <br/>| Any other error | 500 | internalError ||
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| _authorize_representative_ kept for subsequent _sendAuthCodeFdV_ evaluation | if applicable |
        /// </remarks>
        /// <param name="x_idp_iss">The issuer Identifier (URL) of the IDP to be used for user authentication</param>
        /// <param name="x_authorize_representative">This parameter shall be absent or set to _true_ to indicate an authorization request without epa device management registration checks.</param>
        /// <param name="x_authorize_egk">This parameter shall be absent or set to _true_ to indicate an authorization request in guest mode with egk + pin e.g. for validation identities.</param>
        /// <param name="x_redirecturi">An optional redirecturi (URL) to be used in PAR for redirection of the authorizationcode. The redirecturi must be registered as valid on the epa application server (entity statement)</param>
        /// <param name="x_useragent">user agent information</param>
        /// <exception cref="AuthorizationServiceException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task SendAuthorizationRequestFdVAsync(string x_idp_iss, bool? x_authorize_representative, bool? x_authorize_egk, string x_redirecturi, string x_useragent)
        {
            return SendAuthorizationRequestFdVAsync(x_idp_iss, x_authorize_representative, x_authorize_egk, x_redirecturi, x_useragent, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// (sendAuthorizationRequestFdV) Send authorization request
        /// </summary>
        /// <remarks>
        /// Sends an authorization request to the authorization service.
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client shall use parameter _x-authorize_representative_ for the "Authorize Representative" use case,
        /// <br/> a login of a user on not owned device for representative entitlement only.
        /// <br/>The _x-authorize-representative_ parameter will force an authentication of the user with egK + pin only and limit the possible operations to entitlement management only.
        /// <br/>A client shall use the returned redirect url to invoke the authenticator. &lt;br/&gt;
        /// <br/>
        /// <br/>A client shall use parameter _x-authorize-egk_ for a login in guest mode with egk and pin, e.g. of a validation identity 
        /// <br/>(i.e. "Prüfkarte eGK"), forcing the authorization service to request an authentication at the identity provider 
        /// <br/>in guest mode (eGK + pin). 
        /// <br/>A client shall use the returned redirect url to invoke the authenticator.
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The authorization service shall send a pushed authorization request (PAR) to the IDP (see: find more details).
        /// <br/>
        /// <br/>The _redirect_uri_ parameter of the PAR shall be set to a predefined value when operation parameter 
        /// <br/>_x-redirecturi_ is not present, else the content of _x-redirecturi_ shall be used (according to A_25717-*).
        /// <br/>
        /// <br/>The authorize representative situation (_x-authorize-representative_ == _true_) shall be kept for the subsequent
        /// <br/>_sendAuthCodeFdV_ and device management operations. 
        /// <br/>
        /// <br/>For the _x-authorize-representative_ and the _x-authorize-egk_ case the PAR for the IDP shall include:
        /// <br/>- amr = urn:telematik:auth:guest:eGK
        /// <br/>
        /// <br/>_x-authorize-representative_ and _x-authorize-egk_ both should not be set to _true_ at the same time.
        /// <br/>
        /// <br/>This operation shall be rejected if the corresponding user session is already authorized. Repeated authorization
        /// <br/>attempts are not supported.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 302 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest | also if both "x-authorize"-parameters are set to _true_ |
        /// <br/>| Invalid request | 403 | invalAuth | includes any error of Authorization Service and IDP which is not mapped to 500 internal Server error |
        /// <br/>| unregistered redirecturi | 403 | invalRedir | redirecturi in _x-redirecturi_ is not known, registration required |
        /// <br/>| Invalid URI (x-idp-iss) | 404 | noResource | |
        /// <br/>| Repeated authorization attempt | 409 | statusMismatch | when user session is already authorized only |
        /// <br/>| Any other error | 500 | internalError ||
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| _authorize_representative_ kept for subsequent _sendAuthCodeFdV_ evaluation | if applicable |
        /// </remarks>
        /// <param name="x_idp_iss">The issuer Identifier (URL) of the IDP to be used for user authentication</param>
        /// <param name="x_authorize_representative">This parameter shall be absent or set to _true_ to indicate an authorization request without epa device management registration checks.</param>
        /// <param name="x_authorize_egk">This parameter shall be absent or set to _true_ to indicate an authorization request in guest mode with egk + pin e.g. for validation identities.</param>
        /// <param name="x_redirecturi">An optional redirecturi (URL) to be used in PAR for redirection of the authorizationcode. The redirecturi must be registered as valid on the epa application server (entity statement)</param>
        /// <param name="x_useragent">user agent information</param>
        /// <exception cref="AuthorizationServiceException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task SendAuthorizationRequestFdVAsync(string x_idp_iss, bool? x_authorize_representative, bool? x_authorize_egk, string x_redirecturi, string x_useragent, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (x_idp_iss == null)
                        throw new System.ArgumentNullException("x_idp_iss");
                    request_.Headers.TryAddWithoutValidation("x-idp-iss", ConvertToString(x_idp_iss, System.Globalization.CultureInfo.InvariantCulture));

                    if (x_authorize_representative != null)
                        request_.Headers.TryAddWithoutValidation("x-authorize-representative", ConvertToString(x_authorize_representative, System.Globalization.CultureInfo.InvariantCulture));

                    if (x_authorize_egk != null)
                        request_.Headers.TryAddWithoutValidation("x-authorize-egk", ConvertToString(x_authorize_egk, System.Globalization.CultureInfo.InvariantCulture));

                    if (x_redirecturi != null)
                        request_.Headers.TryAddWithoutValidation("x-redirecturi", ConvertToString(x_redirecturi, System.Globalization.CultureInfo.InvariantCulture));

                    if (x_useragent == null)
                        throw new System.ArgumentNullException("x_useragent");
                    request_.Headers.TryAddWithoutValidation("x-useragent", ConvertToString(x_useragent, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "epa/authz/v1/send_authorization_request_fdv"
                    urlBuilder_.Append("epa/authz/v1/send_authorization_request_fdv");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 302)
                        {
                            string responseText_ = ( response_.Content == null ) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new AuthorizationServiceException("Found", status_, responseText_, headers_, null);
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AuthorizationServiceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AuthorizationServiceException<ErrorType>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AuthorizationServiceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AuthorizationServiceException<ErrorType>("Forbidden.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AuthorizationServiceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AuthorizationServiceException<ErrorType>("Not found.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AuthorizationServiceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AuthorizationServiceException<ErrorType>("Conflict.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AuthorizationServiceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AuthorizationServiceException<ErrorType>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else

                        if (status_ == 200 || status_ == 204)
                        {

                            return;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new AuthorizationServiceException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// (sendAuthCodeFdV) Send authorization code
        /// </summary>
        /// <remarks>
        /// Send the authorization code to the authorization service to complete the login and (optional)
        /// <br/>verify the device registration.
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client shall always send the authorization code received from the authenticator / IDP. &lt;br/&gt;
        /// <br/>
        /// <br/>A client shall send both, _x-device-identifier_ and _x-device-token_, on login to the home system
        /// <br/>of the user for proof of a registered device.
        /// <br/>
        /// <br/>If the user has a device registration in another home system, then a device attestation from his home 
        /// <br/>system must be used and a client shall submit _x-device-attestation_ (instead of _x-device-identifier_ 
        /// <br/>and _x-device-token_). A client can obtain a device attestation from the home system via a 
        /// <br/>_getDeviceAttestation_ operation call.  
        /// <br/>
        /// <br/>A client shall not send _x-device-identifier_ and _x-device-token_ or even _x-device-attestation_ 
        /// <br/>(suppress parameters at all) if the device is not yet registered and confirmed or if the preceding 
        /// <br/>_sendAuthorizationRequestFdV_ call includes the parameter _x-authorize_representative_ == _true_.
        /// <br/>
        /// <br/>(For registration of a new device, including confirmation of the registration, see Device Management 
        /// <br/>Service operations _registerDevice_ and _confirmDevice_). 
        /// <br/>
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The provided authorization code shall be exchanged for an ID-Token with the IDP. The ID-Token shall be converted
        /// <br/>into a HSM-ID-Token with an extended validity period.
        /// <br/>
        /// <br/>Device verification - home system:&lt;/br&gt;
        /// <br/>If _x-device-identifier_ and _x-device-token_ are both submitted the device verification starts immediately after
        /// <br/>the authorization completion.
        /// <br/>Device identifier and -token shall be verified with the registered values.
        /// <br/>The x-device-identifier / x-device-token check shall only consider device registrations for the authorized user.
        /// <br/>
        /// <br/>Device verification - other than home system:&lt;/br&gt;
        /// <br/>If _x-device-attestation_ is submitted the device verification starts immediately after the authorization completion.
        /// <br/>The authorization service shall accept a device attestation in case
        /// <br/>  - signature is valid
        /// <br/>  - "exp" expiration_time is a timestamp 120 minutes in the future "iat".
        /// <br/>  - current time is greater or equal than 'iat' and less than 'exp' with 15 seconds tolerance ('iat' - 15s &lt;= current time &lt; 'exp' + 15s).          
        /// <br/>  - claim _actorId_ from device attestation matches kvnr of ID-Token or HSM-ID-Token.
        /// <br/>
        /// <br/>If the device attestation is valid by signature and time, and the KVNR submitted in device attestation matches the 
        /// <br/>KVNR of the authorized user the authorization service shall accept the device registration.
        /// <br/>
        /// <br/>On success (ID-Token / HSM-ID-Token received and device binding check successful) a new user session shall be instantiated, 
        /// <br/>associated to the HSM-ID-Token.
        /// <br/>
        /// <br/>If device verification succeeds, access to all services of a health record shall be possible for the associated
        /// <br/>user session.
        /// <br/>if x-authorize-representative is set, access to the user's health record entitlement management only shall be
        /// <br/>possible for the user session.
        /// <br/>In all other (success cases) access of the user session shall be limited to the device management service.
        /// <br/>
        /// <br/>The user session of a client shall be closed and all session related data shall be deleted in case operation is not successful.
        /// <br/>
        /// <br/>The VAU user preudonym as generated for the vau-channel (see: vau protocol) shall be returned in a successful operation response.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 200 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Only _x-device-identifier_ or _x-device-token_ provided | 400 | paramExcpected | both parameters required or none |
        /// <br/>| (_x-device-identifier_ and/or _x-device-token_) and _x-device-attestation_ provided | 400 | paramExcpected | use only registration of home system, another system or none (yet unregistered device) |
        /// <br/>| _authorize_representative_ is set and _x-device-identifier_ and/or _x-device-token_ and/or x-device-attestation_ provided | 400 | authorizeRep | _x-authorize_representative_ from preceding sendAuthorizationRequestFdV |
        /// <br/>| Requestor role is not _oid_versicherter_ | 403 | invalidOid ||
        /// <br/>| _authorizationCode_ not valid | 403 | invalAuth | includes any error of Authorization Service and IDP which is not mapped to 500 internal Server error |
        /// <br/>| Wrong _x-device-token_  | 403 | invalidToken | if both parameters avaiable and allowed|
        /// <br/>| Invalid _x-device-attestation_ | 403 | invalSignature ||
        /// <br/>| Device registration does not exist (_x-device-identifier_)| 404| noResource | also if device is not associated to requestor kvnr |
        /// <br/>| Device registration not confirmed (_status_ == _pending_) | 409 | statusMismatch | confirm pending device registration before retry |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| user session has valid HSM-ID-Token | successful operation only |
        /// <br/>| user session contains device verification result | successful operation with device parameters only |
        /// <br/>| _lastUse_ of device registration is updated to current time | successful operation with device parameters only |
        /// <br/>| user session and temporary data is deleted | failed operation only |
        /// </remarks>
        /// <param name="x_device_identifier">The deviceidentifier of a device registration</param>
        /// <param name="x_device_token">The devicetoken of a device registration</param>
        /// <param name="x_device_attestation">The deviceAttestation of a device registration</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK, Successful login</returns>
        /// <exception cref="AuthorizationServiceException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<Response4> SendAuthCodeFdVAsync(System.Guid? x_device_identifier, string x_device_token, DeviceAttestationType x_device_attestation, SendAuthCodeFdVtype body, string x_useragent)
        {
            return SendAuthCodeFdVAsync(x_device_identifier, x_device_token, x_device_attestation, body, x_useragent, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// (sendAuthCodeFdV) Send authorization code
        /// </summary>
        /// <remarks>
        /// Send the authorization code to the authorization service to complete the login and (optional)
        /// <br/>verify the device registration.
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client shall always send the authorization code received from the authenticator / IDP. &lt;br/&gt;
        /// <br/>
        /// <br/>A client shall send both, _x-device-identifier_ and _x-device-token_, on login to the home system
        /// <br/>of the user for proof of a registered device.
        /// <br/>
        /// <br/>If the user has a device registration in another home system, then a device attestation from his home 
        /// <br/>system must be used and a client shall submit _x-device-attestation_ (instead of _x-device-identifier_ 
        /// <br/>and _x-device-token_). A client can obtain a device attestation from the home system via a 
        /// <br/>_getDeviceAttestation_ operation call.  
        /// <br/>
        /// <br/>A client shall not send _x-device-identifier_ and _x-device-token_ or even _x-device-attestation_ 
        /// <br/>(suppress parameters at all) if the device is not yet registered and confirmed or if the preceding 
        /// <br/>_sendAuthorizationRequestFdV_ call includes the parameter _x-authorize_representative_ == _true_.
        /// <br/>
        /// <br/>(For registration of a new device, including confirmation of the registration, see Device Management 
        /// <br/>Service operations _registerDevice_ and _confirmDevice_). 
        /// <br/>
        /// <br/>
        /// <br/>**Provider**:&lt;/br&gt;
        /// <br/>The provided authorization code shall be exchanged for an ID-Token with the IDP. The ID-Token shall be converted
        /// <br/>into a HSM-ID-Token with an extended validity period.
        /// <br/>
        /// <br/>Device verification - home system:&lt;/br&gt;
        /// <br/>If _x-device-identifier_ and _x-device-token_ are both submitted the device verification starts immediately after
        /// <br/>the authorization completion.
        /// <br/>Device identifier and -token shall be verified with the registered values.
        /// <br/>The x-device-identifier / x-device-token check shall only consider device registrations for the authorized user.
        /// <br/>
        /// <br/>Device verification - other than home system:&lt;/br&gt;
        /// <br/>If _x-device-attestation_ is submitted the device verification starts immediately after the authorization completion.
        /// <br/>The authorization service shall accept a device attestation in case
        /// <br/>  - signature is valid
        /// <br/>  - "exp" expiration_time is a timestamp 120 minutes in the future "iat".
        /// <br/>  - current time is greater or equal than 'iat' and less than 'exp' with 15 seconds tolerance ('iat' - 15s &lt;= current time &lt; 'exp' + 15s).          
        /// <br/>  - claim _actorId_ from device attestation matches kvnr of ID-Token or HSM-ID-Token.
        /// <br/>
        /// <br/>If the device attestation is valid by signature and time, and the KVNR submitted in device attestation matches the 
        /// <br/>KVNR of the authorized user the authorization service shall accept the device registration.
        /// <br/>
        /// <br/>On success (ID-Token / HSM-ID-Token received and device binding check successful) a new user session shall be instantiated, 
        /// <br/>associated to the HSM-ID-Token.
        /// <br/>
        /// <br/>If device verification succeeds, access to all services of a health record shall be possible for the associated
        /// <br/>user session.
        /// <br/>if x-authorize-representative is set, access to the user's health record entitlement management only shall be
        /// <br/>possible for the user session.
        /// <br/>In all other (success cases) access of the user session shall be limited to the device management service.
        /// <br/>
        /// <br/>The user session of a client shall be closed and all session related data shall be deleted in case operation is not successful.
        /// <br/>
        /// <br/>The VAU user preudonym as generated for the vau-channel (see: vau protocol) shall be returned in a successful operation response.
        /// <br/>
        /// <br/>| Conditions | Status code | Error code | Remarks |
        /// <br/>|------------|-------------|------------|---------|
        /// <br/>| Successful operation | 200 |||
        /// <br/>| Request does not match schema | 400 | malformedRequest ||
        /// <br/>| Only _x-device-identifier_ or _x-device-token_ provided | 400 | paramExcpected | both parameters required or none |
        /// <br/>| (_x-device-identifier_ and/or _x-device-token_) and _x-device-attestation_ provided | 400 | paramExcpected | use only registration of home system, another system or none (yet unregistered device) |
        /// <br/>| _authorize_representative_ is set and _x-device-identifier_ and/or _x-device-token_ and/or x-device-attestation_ provided | 400 | authorizeRep | _x-authorize_representative_ from preceding sendAuthorizationRequestFdV |
        /// <br/>| Requestor role is not _oid_versicherter_ | 403 | invalidOid ||
        /// <br/>| _authorizationCode_ not valid | 403 | invalAuth | includes any error of Authorization Service and IDP which is not mapped to 500 internal Server error |
        /// <br/>| Wrong _x-device-token_  | 403 | invalidToken | if both parameters avaiable and allowed|
        /// <br/>| Invalid _x-device-attestation_ | 403 | invalSignature ||
        /// <br/>| Device registration does not exist (_x-device-identifier_)| 404| noResource | also if device is not associated to requestor kvnr |
        /// <br/>| Device registration not confirmed (_status_ == _pending_) | 409 | statusMismatch | confirm pending device registration before retry |
        /// <br/>| Any other error | 500 | internalError | (see 'Retry interval') |
        /// <br/>
        /// <br/> &lt;/br&gt;
        /// <br/>| Postconditions                        | Remarks |
        /// <br/>|---------------------------------------|---------|
        /// <br/>| user session has valid HSM-ID-Token | successful operation only |
        /// <br/>| user session contains device verification result | successful operation with device parameters only |
        /// <br/>| _lastUse_ of device registration is updated to current time | successful operation with device parameters only |
        /// <br/>| user session and temporary data is deleted | failed operation only |
        /// </remarks>
        /// <param name="x_device_identifier">The deviceidentifier of a device registration</param>
        /// <param name="x_device_token">The devicetoken of a device registration</param>
        /// <param name="x_device_attestation">The deviceAttestation of a device registration</param>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK, Successful login</returns>
        /// <exception cref="AuthorizationServiceException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<Response4> SendAuthCodeFdVAsync(System.Guid? x_device_identifier, string x_device_token, DeviceAttestationType x_device_attestation, SendAuthCodeFdVtype body, string x_useragent, System.Threading.CancellationToken cancellationToken)
        {
            if (body == null)
                throw new System.ArgumentNullException("body");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (x_device_identifier != null)
                        request_.Headers.TryAddWithoutValidation("x-device-identifier", ConvertToString(x_device_identifier, System.Globalization.CultureInfo.InvariantCulture));

                    if (x_device_token != null)
                        request_.Headers.TryAddWithoutValidation("x-device-token", ConvertToString(x_device_token, System.Globalization.CultureInfo.InvariantCulture));

                    if (x_device_attestation != null)
                        request_.Headers.TryAddWithoutValidation("x-device-attestation", ConvertToString(x_device_attestation, System.Globalization.CultureInfo.InvariantCulture));

                    if (x_useragent == null)
                        throw new System.ArgumentNullException("x_useragent");
                    request_.Headers.TryAddWithoutValidation("x-useragent", ConvertToString(x_useragent, System.Globalization.CultureInfo.InvariantCulture));
                    var json_ = System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(body, JsonSerializerSettings);
                    var content_ = new System.Net.Http.ByteArrayContent(json_);
                    content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/json");
                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "epa/authz/v1/send_authcode_fdv"
                    urlBuilder_.Append("epa/authz/v1/send_authcode_fdv");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<Response4>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AuthorizationServiceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AuthorizationServiceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AuthorizationServiceException<ErrorType>("Bad Request.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 403)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AuthorizationServiceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AuthorizationServiceException<ErrorType>("Forbidden", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 404)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AuthorizationServiceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AuthorizationServiceException<ErrorType>("Not found.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 409)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AuthorizationServiceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AuthorizationServiceException<ErrorType>("Conflict.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AuthorizationServiceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AuthorizationServiceException<ErrorType>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new AuthorizationServiceException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <summary>
        /// (logoutFdV) Logout from user session.
        /// </summary>
        /// <remarks>
        /// A logout terminates the associated user session. For any further service usage a new 
        /// <br/>authentication of the user is required. 
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client shall perform this explicit logout to close the user session and all 
        /// <br/>health record related activities. For further access a client shall perform a new login, including
        /// <br/>negotiation of a new VAU-channel.
        /// <br/>
        /// <br/> **Provider**:&lt;/br&gt;
        /// <br/> The user session of a client shall be closed and all session related 
        /// <br/> data shall be deleted. Associated health record contexts shall be released / closed.
        /// <br/>
        /// <br/> | Conditions | Status code | Error code | Remarks |
        /// <br/> |------------|-------------|------------|---------|
        /// <br/> | Successful logout | 204 |||
        /// <br/> | Request does not match schema | 400 | malformedRequest ||
        /// <br/> | Any other error | 500 | internalError ||
        /// <br/>
        /// <br/>  &lt;/br&gt;
        /// <br/> | Postconditions                        | Remarks |
        /// <br/> |---------------------------------------|---------|
        /// <br/> | The user session and all related temporary data is terminated / deleted | successful operation only |
        /// </remarks>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK</returns>
        /// <exception cref="AuthorizationServiceException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task LogoutFdVAsync(string x_useragent)
        {
            return LogoutFdVAsync(x_useragent, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// (logoutFdV) Logout from user session.
        /// </summary>
        /// <remarks>
        /// A logout terminates the associated user session. For any further service usage a new 
        /// <br/>authentication of the user is required. 
        /// <br/>
        /// <br/>**Client**:&lt;/br&gt;
        /// <br/>A client shall perform this explicit logout to close the user session and all 
        /// <br/>health record related activities. For further access a client shall perform a new login, including
        /// <br/>negotiation of a new VAU-channel.
        /// <br/>
        /// <br/> **Provider**:&lt;/br&gt;
        /// <br/> The user session of a client shall be closed and all session related 
        /// <br/> data shall be deleted. Associated health record contexts shall be released / closed.
        /// <br/>
        /// <br/> | Conditions | Status code | Error code | Remarks |
        /// <br/> |------------|-------------|------------|---------|
        /// <br/> | Successful logout | 204 |||
        /// <br/> | Request does not match schema | 400 | malformedRequest ||
        /// <br/> | Any other error | 500 | internalError ||
        /// <br/>
        /// <br/>  &lt;/br&gt;
        /// <br/> | Postconditions                        | Remarks |
        /// <br/> |---------------------------------------|---------|
        /// <br/> | The user session and all related temporary data is terminated / deleted | successful operation only |
        /// </remarks>
        /// <param name="x_useragent">user agent information</param>
        /// <returns>OK</returns>
        /// <exception cref="AuthorizationServiceException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task LogoutFdVAsync(string x_useragent, System.Threading.CancellationToken cancellationToken)
        {
            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    if (x_useragent == null)
                        throw new System.ArgumentNullException("x_useragent");
                    request_.Headers.TryAddWithoutValidation("x-useragent", ConvertToString(x_useragent, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");

                    var urlBuilder_ = new System.Text.StringBuilder();
                
                    // Operation Path: "epa/authz/v1/logoutFdV"
                    urlBuilder_.Append("epa/authz/v1/logoutFdV");

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 204)
                        {
                            return;
                        }
                        else
                        if (status_ == 400)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AuthorizationServiceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AuthorizationServiceException<ErrorType>("Bad Request", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<ErrorType>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new AuthorizationServiceException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new AuthorizationServiceException<ErrorType>("Internal Server Error", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new AuthorizationServiceException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Threading.CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = System.Text.Json.JsonSerializer.Deserialize<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (System.Text.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new AuthorizationServiceException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    {
                        var typedBody = await System.Text.Json.JsonSerializer.DeserializeAsync<T>(responseStream, JsonSerializerSettings, cancellationToken).ConfigureAwait(false);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (System.Text.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new AuthorizationServiceException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is System.Enum)
            {
                var name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = System.Convert.ToString(System.Convert.ChangeType(value, System.Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return System.Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value is string[])
            {
                return string.Join(",", (string[])value);
            }
            else if (value.GetType().IsArray)
            {
                var valueArray = (System.Array)value;
                var valueTextArray = new string[valueArray.Length];
                for (var i = 0; i < valueArray.Length; i++)
                {
                    valueTextArray[i] = ConvertToString(valueArray.GetValue(i), cultureInfo);
                }
                return string.Join(",", valueTextArray);
            }

            var result = System.Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

    /// <summary>
    /// "A JSON Web Token (JWT) with following format build according to RFC-7515:&lt;/br&gt;
    /// <br/>base64url (protected_header) + '.' + base64url (payload) + '.' + base64url (signature)"&lt;/br&gt;
    /// <br/>Content for device attestation:&lt;/br&gt;
    /// <br/>- protected_header contains:
    /// <br/>  - "typ": "JWT"
    /// <br/>  - "alg": "ES256" 
    /// <br/>  - "x5c": signature certificate (C.FD.SIG)
    /// <br/>- payload claims:
    /// <br/>  - "iat" issued_at is the timestamp of the time of issue.
    /// <br/>  - "exp" expiration_time is a timestamp 120 minutes in the future "iat".
    /// <br/>  - "actorId": KVNR
    /// <br/>- signature contains token signature
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DeviceAttestationType
    {

        [System.Text.Json.Serialization.JsonPropertyName("jwt")]
        public string Jwt { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Authorization code and client attestation
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SendAuthCodeSCtype
    {

        [System.Text.Json.Serialization.JsonPropertyName("authorizationCode")]
        public string AuthorizationCode { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("clientAttest")]
        public string ClientAttest { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Authorization code
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SendAuthCodeFdVtype
    {

        [System.Text.Json.Serialization.JsonPropertyName("authorizationCode")]
        public string AuthorizationCode { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Search access-token as received from FHIR Directory
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SearchAccessTokenType
    {

        [System.Text.Json.Serialization.JsonPropertyName("access_token")]
        public string Access_token { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("token_type")]
        public string Token_type { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("expires_in")]
        public int Expires_in { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// "A JSON Web Token (JWT) with following format build according to RFC-7515:&lt;/br&gt;
    /// <br/>base64url (protected_header) + '.' + base64url (payload) + '.' + base64url (signature)"&lt;/br&gt;
    /// <br/>Content for ePrescription backend bearerToken&lt;/br&gt;
    /// <br/>(expiration time is implicite, HSM rule 'rr0' will reject tokens with 'iat' 
    /// <br/>more than 10 minutes in the past of current time.)&lt;/br&gt;
    /// <br/>- protected_header contains:
    /// <br/>  - "typ": "JWT"
    /// <br/>  - "alg": "ES256" 
    /// <br/>  - "x5c": signature certificate c.fd.aut
    /// <br/>- payload claims:
    /// <br/>  - "type": "ePA-Authentisierung über PKI" (fixed value)
    /// <br/>  - "iat" issued_at is the timestamp of the time of issue.
    /// <br/>  - "challenge": freshness parameter (base64 encoded)
    /// <br/>  - "sub": Telematik-ID ePrescription backend
    /// <br/>- signature: contains token signature
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class BearerTokenType
    {

        [System.Text.Json.Serialization.JsonPropertyName("bearerToken")]
        public string BearerToken { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// Error object with additional information about the occurred error
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ErrorType
    {
        /// <summary>
        /// Error condition specifier
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("errorCode")]
        public string ErrorCode { get; set; }

        /// <summary>
        /// Additional details regarding the error condition (if applicable)
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("errorDetail")]
        public string ErrorDetail { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    /// <summary>
    /// A new nonce
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Response
    {

        [System.Text.Json.Serialization.JsonPropertyName("nonce")]
        public string Nonce { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Response2
    {

        [System.Text.Json.Serialization.JsonPropertyName("vau-np")]
        public string VauNp { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Response3
    {
        /// <summary>
        /// A base64 encoded freshness parameter for a bearer token (health record system specific content)
        /// </summary>

        [System.Text.Json.Serialization.JsonPropertyName("freshness")]
        public byte[] Freshness { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Response4
    {

        [System.Text.Json.Serialization.JsonPropertyName("vau-np")]
        public string VauNp { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("actorId")]
        public string ActorId { get; set; }

        [System.Text.Json.Serialization.JsonPropertyName("displayName")]
        public string DisplayName { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties;

        [System.Text.Json.Serialization.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties ?? (_additionalProperties = new System.Collections.Generic.Dictionary<string, object>()); }
            set { _additionalProperties = value; }
        }

    }



    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AuthorizationServiceException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public AuthorizationServiceException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException)
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + ((response == null) ? "(null)" : response.Substring(0, response.Length >= 512 ? 512 : response.Length)), innerException)
        {
            StatusCode = statusCode;
            Response = response;
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AuthorizationServiceException<TResult> : AuthorizationServiceException
    {
        public TResult Result { get; private set; }

        public AuthorizationServiceException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException)
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}

#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625